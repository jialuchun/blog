<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Lucien" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Blogs Of Lucien">
<meta property="og:url" content="https://github.com/jialuchun/blog/index.html">
<meta property="og:site_name" content="Blogs Of Lucien">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blogs Of Lucien">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Blogs Of Lucien" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/blog/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Blogs Of Lucien</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/blog/" class="profilepic">
            <img src="http://mamaj-oss-ws.oss-cn-beijing.aliyuncs.com/free/Jia/luchun/photo.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/blog/">Lucien</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/blog/archives/">主页</a></li>
                        
                            <li><a href="/blog/archives/">所有文章</a></li>
                        
                            <li><a href="/blog/tags/">标签云</a></li>
                        
                            <li><a href="/blog/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/blog/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lucien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/blog/" class="profilepic">
                <img src="http://mamaj-oss-ws.oss-cn-beijing.aliyuncs.com/free/Jia/luchun/photo.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/blog/" title="回到主页">Lucien</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/blog/archives/">主页</a></li>
                
                    <li><a href="/blog/archives/">所有文章</a></li>
                
                    <li><a href="/blog/tags/">标签云</a></li>
                
                    <li><a href="/blog/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/blog/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-20171226 js面向对象的程序设计" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/12/26/20171226 js面向对象的程序设计/" class="article-date">
      <time datetime="2017-12-26T10:41:59.000Z" itemprop="datePublished">2017-12-26</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/12/26/20171226 js面向对象的程序设计/">js 面向对象的程序设计</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 理解对象属性</li>
<li style="list-style: none"><input type="checkbox" checked> 理解并创建对象</li>
<li style="list-style: none"><input type="checkbox" checked> 理解继承<h2 id="1-1-理解对象"><a href="#1-1-理解对象" class="headerlink" title="1.1 理解对象"></a>1.1 理解对象</h2>创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">    person.name = &quot;Nicholas&quot;;</div><div class="line">    person.age = 29;</div><div class="line">    person.job = &quot;Software Engineer&quot;;</div><div class="line">    person.sayName = function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在对象字面量成为创建这种对象的首选模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name: &quot;Nicholas&quot;,</div><div class="line">    age: 29,</div><div class="line">    job: &quot;Software Engineer&quot;,</div><div class="line">    sayName: function()&#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="1-1-1-属性类型"><a href="#1-1-1-属性类型" class="headerlink" title="1.1.1 属性类型"></a>1.1.1 属性类型</h3><p>ECMAScript中有两种属性:数据属性和访问器属性。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 数据属性(数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的<br>特性。)</li>
<li>[[Configurable]]:表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Enumerable]]:表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。</li>
<li>[[Writable]]:表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Value]]:包含这个属性的数据值。读取属性值的时候，从这个位置读;写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ul>
<p>对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值.</p>
<p>要修改属性默认的特性，必须使用 ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数:属性所在的对象、属性的名字和一个描述符对象。其中，描述符(descriptor)对象的属 性必须是:configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对应的特性值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;;</div><div class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</div><div class="line">    writable: false,</div><div class="line">    value: &quot;Nicholas&quot;</div><div class="line">&#125;);</div><div class="line">alert(person.name); //&quot;Nicholas&quot;</div><div class="line">person.name = &quot;Greg&quot;;</div><div class="line">alert(person.name); //&quot;Nicholas&quot;</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 访问器属性(访问器属性不包含数据值;它们包含一对儿 getter 和 setter 函数(不过，这两个函数都不是必需的)。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值;在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。)</li>
<li>[[Configurable]]:表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。</li>
<li>[[Enumerable]]:表示能否通过for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Get]]:在读取属性时调用的函数。默认值为 undefined。</li>
<li>[[Set]]:在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty()来定义。</p>
<h2 id="1-2-创建对象"><a href="#1-2-创建对象" class="headerlink" title="1.2 创建对象"></a>1.2 创建对象</h2><p>虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点:使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>
<h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1. 工厂模式"></a>1. 工厂模式</h3><p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job)&#123;</div><div class="line">    var o = new Object();</div><div class="line">        o.name = name;</div><div class="line">        o.age = age;</div><div class="line">        o.job = job;</div><div class="line">        o.sayName = function()&#123;</div><div class="line">            alert(this.name);</div><div class="line">        &#125;;</div><div class="line">    return o; </div><div class="line">&#125;</div><div class="line">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure></p>
<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。随着 JavaScript 的发展，又一个新模式出现了。</p>
<h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><p>可以使用构造函数模式将前面的例子重写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">        this.job = job;</div><div class="line">        this.sayName = function()&#123;</div><div class="line">            alert(this.name);</div><div class="line">    &#125;; </div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure></p>
<p>区别</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 没有显式地创建对象;</li>
<li style="list-style: none"><input type="checkbox" checked> 直接将属性和方法赋给了 this 对象;</li>
<li style="list-style: none"><input type="checkbox" checked> 没有 return 语句。<br>还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他语言，主要是为了区别于ECMAScript中的其他函数;==因为构造函数本身也是函数，只不过可以用来创建对象而已。==</li>
</ul>
<p>要创建Person的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤:</p>
<ul>
<li>创建一个新对象;</li>
<li>将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象);</li>
<li>执行构造函数中的代码(为这个新对象添加属性);</li>
<li>返回新对象。</li>
</ul>
<p>person1 和 person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor(构造函数)属性，该属性指向 Person.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person1.constructor == Person); //true</div><div class="line">alert(person2.constructor == Person); //true</div></pre></td></tr></table></figure></p>
<p>对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instan- ceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，同时也是Person 的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(person1 instanceof Object);  //true</div><div class="line">alert(person1 instanceof Person);  //true</div><div class="line">alert(person2 instanceof Object);  //true</div><div class="line">alert(person2 instanceof Person);  //true</div></pre></td></tr></table></figure></p>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型;而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1和person2 之所以同时是Object的实例，是因为所有对象均继承自Object</p>
<h4 id="2-1-将构造函数当作函数"><a href="#2-1-将构造函数当作函数" class="headerlink" title="2.1. 将构造函数当作函数"></a>2.1. 将构造函数当作函数</h4><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数;而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 当作构造函数使用</div><div class="line">var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); person.sayName(); //&quot;Nicholas&quot;</div><div class="line"></div><div class="line">// 作为普通函数调用</div><div class="line">Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到window window.sayName(); //&quot;Greg&quot;</div><div class="line"></div><div class="line">// 在另一个对象的作用域中调用</div><div class="line">var o = new Object();</div><div class="line">Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;); o.sayName(); //&quot;Kristen&quot;</div></pre></td></tr></table></figure></p>
<h4 id="2-2-构造函数的问题"><a href="#2-2-构造函数的问题" class="headerlink" title="2.2. 构造函数的问题"></a>2.2. 构造函数的问题</h4><p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个 实例上重新创建一遍。在前面的例子中，person1 和 person2 都有一个名为sayName()的方法，但那 两个方法不是同一个Function的实例。不要忘了ECMAScript 中的函数是对象，因此每定义一个 函数，也就是实例化了一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.job = job;</div><div class="line">    this.sayName = sayName;</div><div class="line">&#125;</div><div class="line">function sayName()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们 将 sayName 属性设置成等于全局的sayName函数。这样一来，由于 sayName 包含的是一个指向函数 的指针，因此person1和person2对象就共享了在全局作用域中定义的同一个sayName()函数。这样做确实解决了两个函数做同一件事的问题，可是新问题又来了:在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是:如果对象需要定义很多方 法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在， 这些问题可以通过使用原型模式来解决。</p>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是 可以将这些信息直接添加到原型对象中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName();   //&quot;Nicholas&quot;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName(); //&quot;Nicholas&quot;</div><div class="line"></div><div class="line">alert(person1.sayName == person2.sayName);  //true</div></pre></td></tr></table></figure></p>
<h4 id="3-1-理解原型对象"><a href="#3-1-理解原型对象" class="headerlink" title="3.1 理解原型对象"></a>3.1 理解原型对象</h4><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor(构造函数)属性，这个属性包含一个指向 prototype属性所在函数的指针。就拿前面的例子来说， Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性;至于其他方法，则都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部属性)，指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中 没有标准的方式访问[[Prototype]]，但Firefox、Safari 和Chrome在每个对象上都支持一个属性__proto__;而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。<br>以前面使用 Person 构造函数和 Person.prototype 创建实例的代码为例，下图展示了各个对 象之间的关系。</p>
<p><img src="https://jialuchun.github.io/images/js_img_1.png" alt="来源红皮书"><br>上图展示了 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例之间的关系</p>
<p>Person.prototype指向了原型对象，而Person.prototype.constructor 又指回了Person。原型对象中除了包含constructor 属性之外，还包括后来添加的其他属性。Person的每个实例—— person1和person2都包含一个内部属性，该属性仅仅指向了 Person.prototype;换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。</p>
<p><strong>原型最初只包含constructor属性，而该属性也是共享的，因此可以通过对象实例访问。</strong></p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name); //&quot;Greg&quot;——来自实例</div><div class="line">alert(person2.name); //&quot;Nicholas&quot;——来自原型</div></pre></td></tr></table></figure></p>
<p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法(不要忘了它是从 Object 继承来的)只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype.name = &quot;Nicholas&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;Software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;));  //false</div><div class="line"></div><div class="line">person1.name = &quot;Greg&quot;;</div><div class="line">alert(person1.name); //&quot;Greg&quot;——来自实例</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //true</div><div class="line"></div><div class="line">alert(person2.name); //&quot;Nicholas&quot;——来自原型</div><div class="line">alert(person2.hasOwnProperty(&quot;name&quot;)); //false</div><div class="line"></div><div class="line">delete person1.name;</div><div class="line">alert(person1.name); //&quot;Nicholas&quot;——来自原型</div><div class="line">alert(person1.hasOwnProperty(&quot;name&quot;)); //false</div></pre></td></tr></table></figure></p>
<h4 id="3-2-原型与-in-操作符"><a href="#3-2-原型与-in-操作符" class="headerlink" title="3.2 原型与 in 操作符"></a>3.2 原型与 in 操作符</h4><p>有两种方式使用 in 操作符:单独使用和在 for-in 循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<h4 id="3-3-更简单的原型语法"><a href="#3-3-更简单的原型语法" class="headerlink" title="3.3 更简单的原型语法"></a>3.3 更简单的原型语法</h4><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    name : &quot;Nicholas&quot;,</div><div class="line">    age : 29,</div><div class="line">    job: &quot;Software Engineer&quot;,</div><div class="line">    sayName : function () &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则 等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设 置回适当的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor : Person,</div><div class="line">    name : &quot;Nicholas&quot;,</div><div class="line">    age : 29,</div><div class="line">    job: &quot;Software Engineer&quot;,</div><div class="line">    sayName : function () &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。</strong></p>
<h4 id="3-4-原型的动态性"><a href="#3-4-原型的动态性" class="headerlink" title="3.4 原型的动态性"></a>3.4 原型的动态性</h4><p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var friend = new Person();</div><div class="line">Person.prototype.sayHi = function()&#123;</div><div class="line">    alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line">friend.sayHi(); //&quot;hi&quot;(没有问题!)</div></pre></td></tr></table></figure></p>
<p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重 写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 [[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 请记住:实例中的指针仅指向原型，而不指向构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">var friend = new Person();</div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor: Person,</div><div class="line">    name : &quot;Nicholas&quot;,</div><div class="line">    age : 29,</div><div class="line">    job : &quot;Software Engineer&quot;,</div><div class="line">    sayName : function () &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">friend.sayName();   //error</div></pre></td></tr></table></figure></p>
<h2 id="1-3-继承"><a href="#1-3-继承" class="headerlink" title="1.3 继承"></a>1.3 继承</h2><p>许多OO语言都支持两种继承方式:接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在 ECMAScript 中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链 来实现的。</p>
<h3 id="1-3-1-原型链"><a href="#1-3-1-原型链" class="headerlink" title="1.3.1 原型链"></a>1.3.1 原型链</h3><p>ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系:每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢?显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function()&#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了 SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.getSubValue = function ()&#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue()); //true</div></pre></td></tr></table></figure></p>
<h4 id="3-1-1-别忘记默认的原型"><a href="#3-1-1-别忘记默认的原型" class="headerlink" title="3.1.1 别忘记默认的原型"></a>3.1.1 别忘记默认的原型</h4><p>所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。</p>
<h4 id="3-1-2-确定原型和实例的关系"><a href="#3-1-2-确定原型和实例的关系" class="headerlink" title="3.1.2 确定原型和实例的关系"></a>3.1.2 确定原型和实例的关系</h4><p>可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用 <strong>instanceof</strong> 操作符，只要用 这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。以下几行代码就说明了这 一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(instance instanceof Object); //true</div><div class="line">alert(instance instanceof SuperType); //true</div><div class="line">alert(instance instanceof SubType); //true</div></pre></td></tr></table></figure></p>
<p>第二种方式是使用<strong>isPrototypeOf()</strong> 方法。同样，只要是原型链中出现过的原型，都可以说是该 原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(Object.prototype.isPrototypeOf(instance)); //true</div><div class="line">alert(SuperType.prototype.isPrototypeOf(instance)); //true</div><div class="line">alert(SubType.prototype.isPrototypeOf(instance)); //true</div></pre></td></tr></table></figure></p>
<h4 id="3-1-3-原型链的问题"><a href="#3-1-3-原型链的问题" class="headerlink" title="3.1.3 原型链的问题"></a>3.1.3 原型链的问题</h4><p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引 用类型值的原型。想必大家还记得，我们前面介绍过包含引用类型值的原型属性会被所有实例共享;而 这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原 型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承了 SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);  //&quot;red,blue,green,black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);  //&quot;red,blue,green,black&quot;</div></pre></td></tr></table></figure></p>
<h3 id="1-3-1-借用构造函数"><a href="#1-3-1-借用构造函数" class="headerlink" title="1.3.1 借用构造函数"></a>1.3.1 借用构造函数</h3><p>有时也叫伪造对象或经典继承，这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象， 因此通过使用apply()和call()方法也可以在(将来)新创建的对象上执行构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">function SubType()&#123;</div><div class="line">    //继承了 SuperType</div><div class="line">    SuperType.call(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors); //&quot;red,blue,green,black&quot;</div><div class="line"></div><div class="line">var instance2 = new SubType();</div><div class="line">alert(instance2.colors);    //&quot;red,blue,green&quot;</div></pre></td></tr></table></figure></p>
<p>代码中加粗的那一行代码“借调”了超类型的构造函数。通过使用 call()方法(或apply()方法也可以)，我们实际上是在(未来将要)新创建的 SubType 实例的环境下调用了 SuperType 构造函数。这样一来，就会在新SubType对象上执行 SuperType()函数中定义的所有对象初始化代码。结果， SubType 的每个实例就都会具有自己的colors属性的副本了。</p>
<ul>
<li>传递参数</li>
</ul>
<p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType()&#123;</div><div class="line">    //继承了 SuperType，同时还传递了参数 SuperType.call(this, &quot;Nicholas&quot;);</div><div class="line">    //实例属性</div><div class="line">    this.age = 29;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.name);    //&quot;Nicholas&quot;;</div><div class="line">alert(instance.age);     //29</div></pre></td></tr></table></figure></p>
<p>以上代码中的 SuperType只接受一个参数name，该参数会直接赋给一个属性。在SubType构造函数内部调用SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。为了确保SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中 定义的属性。</p>
<ul>
<li>借用构造函数的问题</li>
</ul>
<p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。</p>
<h3 id="1-3-2-组合继承"><a href="#1-3-2-组合继承" class="headerlink" title="1.3.2 组合继承"></a>1.3.2 组合继承</h3><p>组合继承，有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)&#123;</div><div class="line">    //继承属性 </div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//继承方法</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);//&quot;red,blue,green,black&quot;</div><div class="line">instance1.sayName();//&quot;Nicholas&quot;;</div><div class="line">instance1.sayAge();//29</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Greg&quot;, 27);</div><div class="line">alert(instance2.colors);//&quot;red,blue,green&quot;</div><div class="line">instance2.sayName();//&quot;Greg&quot;;</div><div class="line">instance2.sayAge();//27</div></pre></td></tr></table></figure></p>
<p>SuperType 构造函数定义了两个属性:name 和 colors。SuperType 的原型定义 了一个方法 sayName()。SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着 又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型 上定义了方法 sayAge()。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法了。</p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="1-3-3-原型式继承-略"><a href="#1-3-3-原型式继承-略" class="headerlink" title="1.3.3 原型式继承(略)"></a>1.3.3 原型式继承(略)</h3><h3 id="1-3-4-寄生式继承-略"><a href="#1-3-4-寄生式继承-略" class="headerlink" title="1.3.4 寄生式继承(略)"></a>1.3.4 寄生式继承(略)</h3><h3 id="1-3-5-寄生组合式继承"><a href="#1-3-5-寄生组合式继承" class="headerlink" title="1.3.5 寄生组合式继承"></a>1.3.5 寄生组合式继承</h3><p>前面说过，组合继承是JavaScript最常用的继承模式;不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数:一次是在创建子类型原型的时候，另一次是 在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子 类型构造函数时重写这些属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)&#123;</div><div class="line">    SuperType.call(this, name);//第二次调用SuperType()</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType();//第一次调用SuperType()</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在第一次调用SuperType构造函数时，SubType.prototype 会得到两个属性:name和colors;它们都是 SuperType 的实例属性，只不过 现在位于SubType 的原型中。当调用SubType构造函数时，又会调用一次 SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性.</p>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">    var prototype=object(superType.prototype);//创建对象</div><div class="line">    prototype.constructor = subType;//增强对象</div><div class="line">    subType.prototype = prototype;//指定对象</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个示例中的 inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两 个参数:子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二 步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。 最后一步，将新创建的对象(即副本)赋值给子类型的原型。这样，我们就可以用调用 inherit- Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function SuperType(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)&#123;</div><div class="line">    SuperType.call(this, name);</div><div class="line">    this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">    alert(this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变;因此，还能够正常使用 instanceof 和 isPrototypeOf()。<strong>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ECMAScript 支持面向对象(OO)编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来 被构造函数模式所取代。</li>
<li style="list-style: none"><input type="checkbox" checked> 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不 过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局 限于任何对象(即与对象具有松散耦合的特点)，因此没有理由不在多个对象间共享函数。</li>
<li style="list-style: none"><input type="checkbox" checked> 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造 函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。</li>
</ul>
<p>JavaScript 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函<br>数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借 用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的 属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用 原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。</p>
<p>此外，还存在下列可供选择的继承模式。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</li>
<li style="list-style: none"><input type="checkbox" checked> 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。</li>
<li style="list-style: none"><input type="checkbox" checked> 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20171128 js引用类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/11/28/20171128 js引用类型/" class="article-date">
      <time datetime="2017-11-28T12:31:49.000Z" itemprop="datePublished">2017-11-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/11/28/20171128 js引用类型/">js 引用类型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 使用对象</li>
<li style="list-style: none"><input type="checkbox" checked> 创建并操作数组</li>
<li style="list-style: none"><input type="checkbox" checked> 理解基本的JavaScript类型</li>
<li style="list-style: none"><input type="checkbox" checked> 使用基本类型和基本包装类型<h2 id="1-1-Object类型"><a href="#1-1-Object类型" class="headerlink" title="1.1 Object类型"></a>1.1 Object类型</h2>==创建Object实例的方式有两种==。</li>
<li><p>第一种是使用 new 操作符后跟 Object 构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
</li>
<li><p>另一种方式是使用对象字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name : &quot;Nicholas&quot;,</div><div class="line">    age : 29</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-2-Array类型"><a href="#1-2-Array类型" class="headerlink" title="1.2 Array类型"></a>1.2 Array类型</h2><p>==创建数组的基本方式有两种==。</p>
<ul>
<li><p>第一种是使用Array构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = new Array();</div><div class="line">var colors = new Array(20);</div><div class="line">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">var colors = Array(3); // 创建一个包含 3 项的数组</div><div class="line">var names = Array(&quot;Greg&quot;); // 创建一个包含 1 项，即字符串&quot;Greg&quot;的数组</div></pre></td></tr></table></figure>
</li>
<li><p>使用数组字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</div><div class="line">var names = []; // 创建一个空数组</div><div class="line">var values = [1,2,]; // 不要这样!这样会创建一个包含 2 或 3 项的数组</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-1-检测数组"><a href="#1-2-1-检测数组" class="headerlink" title="1.2.1 检测数组"></a>1.2.1 检测数组</h3><ul>
<li>instanceof 操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (value instanceof Array)&#123;    </div><div class="line">    //对数组执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实 际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自 不同的构造函数。</p>
<ul>
<li>Array.isArray()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (Array.isArray(value))&#123; </div><div class="line">    //对数组执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<h3 id="1-2-2-转换方法"><a href="#1-2-2-转换方法" class="headerlink" title="1.2.2 转换方法"></a>1.2.2 转换方法</h3><p>所有对象都具有toLocaleString()、toString()和 valueOf()方法。</p>
<ul>
<li>调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</li>
<li>valueOf()返回的还是数组</li>
</ul>
<p>数组继承的toLocaleString()、toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 join()方法，则可以使用不同的分隔符来构建这个字符串。</p>
<h3 id="1-2-3-栈方法"><a href="#1-2-3-栈方法" class="headerlink" title="1.2.3 栈方法"></a>1.2.3 栈方法</h3><p>栈是一种LIFO(Last-In-First-Out，后进先出)的数据结构，也就是最新添加的项最早被移除。</p>
<p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。</p>
<ul>
<li>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并==返回修改后数组的长度==。</li>
<li>pop()方法则从数组末尾移除最后一项，减少数组的 length值，然后==返回移除的项==。<h3 id="1-2-4-队列方法"><a href="#1-2-4-队列方法" class="headerlink" title="1.2.4 队列方法"></a>1.2.4 队列方法</h3>队列数据结构的访问规则是FIFO(First-In-First-Out， 先进先出)。</li>
</ul>
<p>结合使用 shift()和push()方法，可以像使 用队列一样使用数组。</p>
<p>同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p>
<h3 id="1-2-5-重排序方法"><a href="#1-2-5-重排序方法" class="headerlink" title="1.2.5 重排序方法"></a>1.2.5 重排序方法</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> reverse()</li>
<li>reverse()方法会反转数组项的顺序</li>
<li style="list-style: none"><input type="checkbox" checked> sort()</li>
<li>sort()方法按升序排列数组项。</li>
<li>sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。这种排序方式在很多情况下都不是最佳方案。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0, 1, 5, 10, 15];</div><div class="line">values.sort();</div><div class="line">alert(values);     //0,1,10,15,5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>==解决排序方案：==<br>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。</p>
<p>该比较函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b，其返回值如下：</p>
<ul>
<li>若a小于b，在排序后的数组中a应该出现在 b 之前，则返回一个小于0的值。</li>
<li>若a等于b，则返回 0。</li>
<li>若a大于b，则返回一个大于0的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">    if (value1 &lt; value2) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125; else if (value1 &gt; value2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort()方法即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0, 1, 5, 10, 15];</div><div class="line">values.sort(compare);</div><div class="line">alert(values); //0,1,5,10,15</div></pre></td></tr></table></figure></p>
<p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2)&#123;</div><div class="line">    return value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-6-操作方法"><a href="#1-2-6-操作方法" class="headerlink" title="1.2.6 操作方法"></a>1.2.6 操作方法</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> concat()</li>
<li>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。</li>
<li style="list-style: none"><input type="checkbox" checked> slice()</li>
<li>它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项— —==<strong>但不包括结束位置的项</strong>==。注意，==slice()方法不会影响原始数组==。</li>
<li><p>如果结束位置小于起始位置，则返回空数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</div><div class="line">var colors2 = colors.slice(1);</div><div class="line">var colors3 = colors.slice(1,4);</div><div class="line">alert(colors2);   //green,blue,yellow,purple</div><div class="line">alert(colors3);   //green,blue,yellow</div></pre></td></tr></table></figure>
</li>
<li><p>[x] splice()</p>
</li>
<li>splice()的主要用途是向数组的中部插入项：删除、插入、替换</li>
<li><strong>删除</strong>:可以删除任意数量的项，只需指定2个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项。</li>
<li><strong>插入</strong>:可以向指定位置插入任意数量的项，只需提供 3个参数:起始位置、0(要删除的项数)和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li><strong>替换</strong>:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”。</li>
<li>==splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)。==</li>
<li>示例代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</div><div class="line">var removed = colors.splice(0,1);   // 删除第一项</div><div class="line">alert(colors); // green,blue </div><div class="line">alert(removed);//red，返回的数组中只包含一项</div><div class="line"></div><div class="line"></div><div class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置 1 开始插入两项</div><div class="line">alert(colors); // green,yellow,orange,blue</div><div class="line">alert(removed); // 返回的是一个空数组</div><div class="line"></div><div class="line"></div><div class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两项，删除一项</div><div class="line">alert(colors);  //green,red,purple,orange,blue</div><div class="line">alert(removed); //yellow，返回的数组中只包含一项</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-7-位置方法"><a href="#1-2-7-位置方法" class="headerlink" title="1.2.7 位置方法"></a>1.2.7 位置方法</h3><p>indexOf()和 lastIndexOf()。这两个方法都接收两个参数:要查找的项和(可选的)表示查找起点位置的索引。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1</p>
<p>在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> indexOf()</li>
<li>indexOf()方法从数组的开头(位置0)开始向后查找</li>
<li style="list-style: none"><input type="checkbox" checked> lastIndexOf()</li>
<li>lastIndexOf()方法可返回一个指定的字符串值==最后出现的位置==，在一个字符串中的指定位置从后向前搜索。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">alert(numbers.indexOf(4));  //3</div><div class="line">alert(numbers.lastIndexOf(4)); //5</div><div class="line">alert(numbers.indexOf(4, 4));     //5</div><div class="line">alert(numbers.lastIndexOf(4, 4)); //3</div><div class="line"></div><div class="line">var person = &#123; name: &quot;Nicholas&quot; &#125;;</div><div class="line">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</div><div class="line">var morePeople = [person];</div><div class="line">alert(people.indexOf(person));     //-1</div><div class="line">alert(morePeople.indexOf(person)); //0</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-8-迭代方法"><a href="#1-2-8-迭代方法" class="headerlink" title="1.2.8 迭代方法"></a>1.2.8 迭代方法</h3><p><strong>以下方法都不会修改数组中的包含的值。</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> every()</li>
<li>every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true</li>
<li style="list-style: none"><input type="checkbox" checked> some()</li>
<li>some():对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</li>
<li style="list-style: none"><input type="checkbox" checked> filter()</li>
<li>filter():对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li style="list-style: none"><input type="checkbox" checked> forEach()</li>
<li>forEach():对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li style="list-style: none"><input type="checkbox" checked> map()</li>
<li>map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
</ul>
<p>==every()、some()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.every(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">alert(everyResult); //false</div><div class="line"></div><div class="line">var someResult = numbers.some(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">alert(someResult); //true</div></pre></td></tr></table></figure></p>
<p>==filter()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var filterResult = numbers.filter(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">alert(filterResult);    //[3,4,5,4,3]</div></pre></td></tr></table></figure></p>
<p>==map()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var mapResult = numbers.map(function(item, index, array)&#123;</div><div class="line">    return item * 2;</div><div class="line">&#125;);</div><div class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</div></pre></td></tr></table></figure></p>
<p>==forEach()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">numbers.forEach(function(item, index, array)&#123;</div><div class="line">    //执行某些操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="1-2-9归并方法"><a href="#1-2-9归并方法" class="headerlink" title="1.2.9归并方法"></a>1.2.9归并方法</h3><p>这两个方法都接收两个参数:一个在每一项上调用的函数和(可选的)作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收4 个参数:前一个值、当前值、项的索引和数组对象。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> reduce()</li>
<li>reduce()方法从数组的第一项开始，逐个遍历到最后</li>
<li style="list-style: none"><input type="checkbox" checked> reduceRight()</li>
<li>reduceRight()则从数组的最后一项开始，向前遍历到第一项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var values = [1,2,3,4,5];</div><div class="line">var sum = values.reduce(function(prev, cur, index, array)&#123;</div><div class="line">    return prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); //15</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一次执行回调函数，prev 是 1，cur 是 2。第二次，prev 是 3(1 加 2 的结果)，cur 是 3(数组 的第三项)。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。<br>reduceRight()的作用类似，只不过方向相反而已。</p>
<h2 id="1-3-Date类型"><a href="#1-3-Date类型" class="headerlink" title="1.3 Date类型"></a>1.3 Date类型</h2><p>常用的日期方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Date(); // 返回当日的日期和时间。</div><div class="line">Data.now();//返回表示调用这个方法时的日期和时间的毫秒数</div><div class="line">var myDate=new Date();  //创建日期对象</div><div class="line">getTime();//返回 1970 年 1 月 1 日至今的毫秒数。</div><div class="line">getFullYear();//从 Date 对象以四位数字返回年份。</div><div class="line">getMonth();//从 Date 对象返回月份 (0 ~ 11)。</div><div class="line">getDate();//从 Date 对象返回一个月中的某一天 (1 ~ 31)。</div><div class="line">getDay();//从 Date 对象返回一周中的某一天 (0 ~ 6)。</div><div class="line">getHours();//返回 Date 对象的小时 (0 ~ 23)。</div><div class="line">getMinutes();//返回 Date 对象的分钟 (0 ~ 59)。</div><div class="line">getSeconds();//返回 Date 对象的秒数 (0 ~ 59)。</div></pre></td></tr></table></figure></p>
<h2 id="1-4-RegExp类型"><a href="#1-4-RegExp类型" class="headerlink" title="1.4 RegExp类型"></a>1.4 RegExp类型</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 字面量形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags ; //语法</div></pre></td></tr></table></figure>
</li>
</ul>
<p>模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。</p>
<p>每个正则表达式都可带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志。</p>
<ul>
<li>g:表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止;</li>
<li>i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写;</li>
<li>m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*匹配字符串中所有&quot;at&quot;的实例</div><div class="line">*/</div><div class="line">var pattern1 = /at/g; </div><div class="line"></div><div class="line">/*</div><div class="line">*匹配第一个&quot;bat&quot;或“cat”，不区分大小写</div><div class="line">*/</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">/* 10 </div><div class="line">* 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写</div><div class="line">*/</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与其他语言中的正则表达式类似，<strong>模式中使用的所有元字符都必须转义</strong>。正则表达式中的元字符包括:==( [ { \ ^ $ | ) ? * + .]}==</p>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*匹配第一个“bat”或“cat”，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配第一个&quot; [bc]at&quot;，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern2 = /\[bc\]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern3 = /.at/gi;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配所有&quot;.at&quot;，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern4 = /\.at/gi;</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> RegExp构造函数形式</li>
</ul>
<p>它接收两个参数:一个是要匹配的字符串模式，另一个是可选的标志字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> RegExp实例方法</li>
<li>exec()</li>
<li>test()<h2 id="1-5-Function类型"><a href="#1-5-Function类型" class="headerlink" title="1.5 Function类型"></a>1.5 Function类型</h2><strong>每个函数都是 Function 类型的实例</strong>，而且都与其他引用类型一样具有属性和方法。<h3 id="1-5-1-函数声明与函数表达式"><a href="#1-5-1-函数声明与函数表达式" class="headerlink" title="1.5.1 函数声明与函数表达式"></a>1.5.1 函数声明与函数表达式</h3>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问);至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。<h3 id="1-5-2-作为值的函数"><a href="#1-5-2-作为值的函数" class="headerlink" title="1.5.2 作为值的函数"></a>1.5.2 作为值的函数</h3>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function callSomeFunction(someFunction,someArgument)&#123;</div><div class="line">    return someFunction(someArgument);</div><div class="line">&#125;</div><div class="line">function add10(num)&#123;</div><div class="line">    return num + 10;</div><div class="line">&#125;</div><div class="line">var result1 = callSomeFunction(add10, 10);</div><div class="line">alert(result1);   //20</div><div class="line"></div><div class="line">function getGreeting(name)&#123;</div><div class="line">    return &quot;Hello, &quot; + name;</div><div class="line">&#125;</div><div class="line">var result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);</div><div class="line">alert(result2);   //&quot;Hello, Nicholas&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。</p>
<h3 id="1-5-3-函数内部属性"><a href="#1-5-3-函数内部属性" class="headerlink" title="1.5.3 函数内部属性"></a>1.5.3 函数内部属性</h3><p>在函数内部，有两个特殊的对象:arguments 和 this。<br>虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if (num &lt;=1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num-1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义阶乘函数一般都要用到递归算法;如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if (num &lt;=1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num-1)</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个重写后的factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var trueFactorial = factorial;</div><div class="line">factorial = function()&#123;</div><div class="line">    return 0;</div><div class="line">&#125;;</div><div class="line">alert(trueFactorial(5));     //120</div><div class="line">alert(factorial(5));         //0</div></pre></td></tr></table></figure></p>
<p>在此，变量 trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的 factorial() 那样不使用arguments.callee，调用 trueFactorial()就会返回0。可是，在解除了函数体内的代 码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘;至于factorial()，它现在只是一个返回 0 的函数。</p>
<p>this 引用的是函数据以执行的环境对象——或者也可以说是 this 值(当在网页的全局作用域中调用函数时， this 对象引用的就是 window)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor();     //&quot;red&quot;</div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();   //&quot;blue&quot;</div></pre></td></tr></table></figure></p>
<h3 id="1-5-4-函数属性和方法"><a href="#1-5-4-函数属性和方法" class="headerlink" title="1.5.4 函数属性和方法"></a>1.5.4 函数属性和方法</h3><p>每个函数都包含两个属性:length和prototype。其中，length 属性表示函数希望接收的命名参数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum.length);   //2</div></pre></td></tr></table></figure></p>
<p>prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访 问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的。在ECMAScript5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法:apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p>
<p><strong>call()方法与apply()方法的作用相同，它们的区别仅在于</strong>接收参数的方式不同。对于call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">function callSum(num1, num2)&#123;</div><div class="line">    return sum.call(this, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(10,10));   //20</div></pre></td></tr></table></figure></p>
<p>在使用 call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用 apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。 如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply() 肯定更方便;否则，选择 call()可能更合适。</p>
<p>传递参数并非 apply()和call()真正的用武之地;<strong>它们真正强大的地方是能够扩充函数赖以运行的作用域。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor(); //red</div><div class="line">sayColor.call(this); //red</div><div class="line">sayColor.call(window); //red</div><div class="line">sayColor.call(o); //blue</div></pre></td></tr></table></figure></p>
<p>ECMAScript 5 还定义了一个方法:bind()。这个方法会创建一个函数的实例，其 this 值会被绑 定到传给 bind()函数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">var objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor();    //blue</div></pre></td></tr></table></figure></p>
<h3 id="1-5-6-基本包装类型"><a href="#1-5-6-基本包装类型" class="headerlink" title="1.5.6 基本包装类型"></a>1.5.6 基本包装类型</h3><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型:Boolean、Number 和 String。</p>
<p>==每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s2; // &quot;me text&quot;</div></pre></td></tr></table></figure></p>
<p>基本类型值不是对象，因而从逻辑上讲它们不应该有方法。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 创建 String 类型的一个实例;</li>
<li style="list-style: none"><input type="checkbox" checked> 在实例上调用指定的方法;</li>
<li style="list-style: none"><input type="checkbox" checked> 销毁这个实例。</li>
</ul>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = new String(&quot;some text&quot;);</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s1 = null;</div></pre></td></tr></table></figure></p>
<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</strong>。来看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">alert(s1.color);   //undefined</div></pre></td></tr></table></figure></p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>Boolean 类型的实例重写了valueOf()方法，返回基本类型值 true 或 false;重写了 toString() 方法，返回字符串”true”和”false”。可是，Boolean 对象在 ECMAScript 中的用处不大，因为它经 常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var falseObject = new Boolean(false);</div><div class="line">var result = falseObject &amp;&amp; true;</div><div class="line">alert(result);  //true</div><div class="line"></div><div class="line">var falseValue = false;</div><div class="line">result = falseValue &amp;&amp; true;</div><div class="line">alert(result);  //false</div></pre></td></tr></table></figure></p>
<p>基本类型与引用类型的布尔值还有两个区别。首先，typeof 操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是 Boolean 类型的实例，所以使用instanceof操作符测试 Boolean对象会返回true，而测试基本类型的布尔值则返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(typeoffalseObject); //object</div><div class="line">alert(typeof falseValue); //boolean</div><div class="line">alert(falseObject instanceof Boolean);//true</div><div class="line">alert(falseValue instanceof Boolean);//false</div></pre></td></tr></table></figure></p>
<p><strong>建议是永远不要使 用 Boolean 对象。</strong></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>Number 类型也重写了valueOf()、toLocaleString()和 toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。</p>
<p>可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString()); //&quot;10&quot;</div><div class="line">alert(num.toString(2)); //&quot;1010&quot;</div><div class="line">alert(num.toString(8)); //&quot;12&quot;</div><div class="line">alert(num.toString(10)); //&quot;10&quot;</div><div class="line">alert(num.toString(16)); //&quot;a&quot;</div></pre></td></tr></table></figure></p>
<p>除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toFixed(2));  //&quot;10.00&quot;</div></pre></td></tr></table></figure></p>
<p>我们仍 然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用 typeof 和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocale- String()和 toString()方法，都返回对象所表示的基本字符串值。</p>
<p>String 类型的每个实例都有一个length属性，表示字符串中包含多个字符。</p>
<p>String 类型提供了很多方法，用于辅助完成对 ECMAScript中字符串的解析和操作.</p>
<h5 id="1-字符方法"><a href="#1-字符方法" class="headerlink" title="1. 字符方法"></a>1. 字符方法</h5><p>两个用于访问字符串中特定字符的方法是:charAt()和 charCodeAt()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charAt(1));   //&quot;e&quot;</div><div class="line"></div><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charCodeAt(1));//输出&quot;101&quot;</div></pre></td></tr></table></figure></p>
<h5 id="2-字符串操作方法"><a href="#2-字符串操作方法" class="headerlink" title="2. 字符串操作方法"></a>2. 字符串操作方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> concat()</li>
<li><p>用于将一或多个字符串拼接起来,返回拼接得到的新字符串.()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &apos;hello &apos;;</div><div class="line">var result = stringValue.concat(&apos;world&apos;);</div><div class="line">alert(result); // &apos;hello world&apos;</div><div class="line">alert(stringValue); // &apos;hello &apos;</div></pre></td></tr></table></figure>
</li>
<li><p>[x] slice()、substr()和 substring()</p>
</li>
<li><p>它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.substring(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.substr(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.slice(3, 7));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3,7));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substr(3, 7));//&quot;lo worl&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传 入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为 0。最后，substring()方法会把所有负值参数都转换为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(-3));//&quot;rld&quot;</div><div class="line">alert(stringValue.substring(-3));//&quot;hello world&quot;</div><div class="line">alert(stringValue.substr(-3));//&quot;rld&quot;</div><div class="line">alert(stringValue.slice(3, -4));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, -4));//&quot;hel&quot;</div><div class="line">alert(stringValue.substr(3, -4));//&quot;&quot;(空字符串)</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-字符串位置方法"><a href="#3-字符串位置方法" class="headerlink" title="3. 字符串位置方法"></a>3. 字符串位置方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> indexOf()和lastIndexOf()</li>
<li>从一个字符串中搜索给定的子字符串，然后返子字符串的位置(如果没有找到该子字符串，则返回-1)。这两个方法的区别在于:indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;));//4</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));//7</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;, 6));//7</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); //4</div></pre></td></tr></table></figure>
<h5 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4. trim()方法"></a>4. trim()方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;   hello world   &quot;;</div><div class="line">var trimmedStringValue = stringValue.trim();</div><div class="line">alert(stringValue);//&quot;   hello world   &quot;</div><div class="line">alert(trimmedStringValue);//&quot;hello world&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-字符串大小写转换方法"><a href="#5-字符串大小写转换方法" class="headerlink" title="5. 字符串大小写转换方法"></a>5. 字符串大小写转换方法</h5><p>ECMAScript 中涉及字符串大小写转换的方法有 4 个:toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()。其中，toLowerCase()和toUpperCase()是两个经典的方法,toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现.</p>
<h5 id="6-split"><a href="#6-split" class="headerlink" title="6. split()"></a>6. split()</h5><p>这个方法可以基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方 法不会将字符串看成正则表达式)。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red,blue,green,yellow&quot;;</div><div class="line">var colors1 =colorText.split(&quot;,&quot;); //[&apos;red&apos;,&apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos;]</div><div class="line">var colors2 = colorText.split(&quot;,&quot;, 2); //[&quot;red&quot;, &quot;blue&quot;]</div><div class="line">var colors3 = colorText.split(/[^\,]+/); //[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="1-5-7-单体内置对象"><a href="#1-5-7-单体内置对象" class="headerlink" title="1.5.7 单体内置对象"></a>1.5.7 单体内置对象</h3><p>ECMA-262 对内置对象的定义是:“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对 象在 ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object、Array 和 String。<br>ECMA-262还定义了两个单体内置对象:Global 和 Math。</p>
<h4 id="1-Global对象"><a href="#1-Global对象" class="headerlink" title="1. Global对象"></a>1. Global对象</h4><p>ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的.</p>
<p>isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global 对象还包含其他一些方法。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> URI 编码方法</li>
<li>encodeURI()和encodeURIComponent()方法可以对 URI(UniformResourceIdentifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对URI进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</li>
<li>encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对 URI 中的某一段进行编码。</li>
<li>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号;而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http://www.wrox.com/illegalvalue.htm#start&quot;;</div><div class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</div><div class="line">alert(encodeURI(uri));</div><div class="line"></div><div class="line">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</div><div class="line">alert(encodeURIComponent(uri));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 %20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以 对整个 URI 使用encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent() 的原因所在。</p>
<p><strong>一般来说，我们使用 encodeURIComponent()方法的时候要比使用 encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</strong></p>
<p>与 encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> eval()方法</li>
<li><p>eval() 方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript) 字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eval(&quot;alert(&apos;hi&apos;)&quot;);</div><div class="line">相当于</div><div class="line">alert(&quot;hi&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>[x] Global 对象的属性</p>
</li>
<li>特殊的值undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和Function，也都是Global 对象的属性。Global对象的所有属性:</li>
<li>undefined、NaN、Infinity、Object、Array、Function、Boolean、String、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</li>
<li style="list-style: none"><input type="checkbox" checked> window对象</li>
<li>ECMAScript虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window 对象的属性。<h4 id="2-Math对象"><a href="#2-Math对象" class="headerlink" title="2. Math对象"></a>2. Math对象</h4></li>
<li><p>[x] min()和 max()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var max = Math.max(3, 54, 32, 16);</div><div class="line">alert(max);    //54</div><div class="line">var min = Math.min(3, 54, 32, 16);</div><div class="line">alert(min);    //3</div></pre></td></tr></table></figure>
</li>
<li><p>在数组中找出最大值或最小值，使用apply()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5,6,7];</div><div class="line">var max = Math.max.apply(Math, arr);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个技巧的关键是把Math对象作为apply()的第一个参数，从而正确地设置 this 值。然后，可 以将任何数组作为第二个参数。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 舍入方法</li>
</ul>
<p>下面来介绍将小数值舍入为整数的几个方法:Math.ceil()、Math.floor()和Math.round()。这三个方法分别遵循下列舍入规则:</p>
<ul>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数;</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数;</li>
<li><p>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alert(Math.ceil(25.9));     //26</div><div class="line">alert(Math.ceil(25.5));     //26</div><div class="line">alert(Math.ceil(25.1));     //26</div><div class="line">alert(Math.round(25.9));    //26</div><div class="line">alert(Math.round(25.5));    //26</div><div class="line">alert(Math.round(25.1));    //25</div><div class="line">alert(Math.floor(25.9));    //25</div><div class="line">alert(Math.floor(25.5));    //25</div><div class="line">alert(Math.floor(25.1));    //25</div></pre></td></tr></table></figure>
</li>
<li><p>[x] random()方法</p>
</li>
</ul>
<p>Math.random()方法返回大于等于 0 小于 1 的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random() 从某个整数范围内随机选择一个值。</p>
<p><strong>==值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)==</strong></p>
<p>公式中用到了 Math.floor()方法，这是因为 Math.random()总返回一个小数值。而用这个小数 值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个 1 到 10 之间的数值，可以像下面这样编写代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = Math.floor(Math.random() * 10 + 1);</div></pre></td></tr></table></figure>
<p>总共有 10 个可能的值(1到10)，而第一个可能的值是1。而如果想要选择一个介于 2 到 10 之间的值，就应该将上面的代码改成这样:<br>var num = Math.floor(Math.random() * 9 + 2);</p>
<p>从 2 数到 10 要数9个数，因此可能值的总数就是 9，而第一个可能的值就是 2。多数情况下，其实 都可以通过一个函数来计算可能值的总数和第一个可能的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function selectFrom(lowerValue, upperValue) &#123;</div><div class="line">    var choices = upperValue - lowerValue + 1;</div><div class="line">    return Math.floor(Math.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line">var num = selectFrom(2, 10);</div><div class="line">alert(num); // 介于2和10之间(包括2和10)的一个数值</div></pre></td></tr></table></figure></p>
<p>从数组中随机 取出一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;]; </div><div class="line">var color = colors[selectFrom(0, colors.length-1)];</div><div class="line">alert(color);//可能是数组中包含的任何一个字符串</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 其他方法(略)</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象， 现简要总结如下:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 引用类型与传统面向对象程序设计中的类相似，但实现不同</li>
<li style="list-style: none"><input type="checkbox" checked> Object是一个基础类型，其他所有类型都从 Object继承了基本的行为;</li>
<li style="list-style: none"><input type="checkbox" checked> Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能;</li>
<li style="list-style: none"><input type="checkbox" checked> Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能;</li>
<li style="list-style: none"><input type="checkbox" checked> RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表 达式功能。</li>
</ul>
<p>函数实际上是Function类型的实例，因此函数也是对象;而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。</p>
<p>因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类 型分别是:Boolean、Number和String。以下是它们共同的特征:</p>
<ul>
<li>每个包装类型都映射到同名的基本类型;</li>
<li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作;</li>
<li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li>
</ul>
<p>在所有代码执行之前，作用域中就已经存在两个内置对象:Global 和 Math。在大多数 ECMAScript 实现中都不能直接访问 Global 对象;不过，Web 浏览器实现了承担该角色的 window 对象。全局变 量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算 任务。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20171019 js变量、作用域、内存" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/10/19/20171019 js变量、作用域、内存/" class="article-date">
      <time datetime="2017-10-19T11:46:32.000Z" itemprop="datePublished">2017-10-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/10/19/20171019 js变量、作用域、内存/">js 变量、作用域、内存</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 理解基本类型和引用类型的值</li>
<li style="list-style: none"><input type="checkbox" checked> 理解执行环境</li>
<li style="list-style: none"><input type="checkbox" checked> 理解垃圾收集<h2 id="1-1-基本类型和引用类型的值"><a href="#1-1-基本类型和引用类型的值" class="headerlink" title="1.1 基本类型和引用类型的值"></a>1.1 基本类型和引用类型的值</h2>基本类型值指的是 简单的数据段，而引用类型值指那些可能由多个值构成的对象。<h3 id="1-1-1-动态的属性"><a href="#1-1-1-动态的属性" class="headerlink" title="1.1.1 动态的属性"></a>1.1.1 动态的属性</h3>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。<h3 id="1-1-2-复制变量值"><a href="#1-1-2-复制变量值" class="headerlink" title="1.1.2 复制变量值"></a>1.1.2 复制变量值</h3><strong>基本类型</strong>:如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。<br><strong>引用类型</strong>:当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。<h3 id="1-1-3-传递参数"><a href="#1-1-3-传递参数" class="headerlink" title="1.1.3 传递参数"></a>1.1.3 传递参数</h3>ECMAScript中所有函数的参数都是按值传递的。<strong>访问变量有按值和按引用两种方式，而参数只能按值传递。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setName(obj) &#123; </div><div class="line">obj.name = &quot;Nicholas&quot;; </div><div class="line">obj = new Object(); </div><div class="line">obj.name = &quot;Greg&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);    //&quot;Nicholas&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。<br><strong>可以把ECMAScript函数的参数想象成局部变量。</strong></p>
<h3 id="1-1-4-检测类型"><a href="#1-1-4-检测类型" class="headerlink" title="1.1.4 检测类型"></a>1.1.4 检测类型</h3><p>typeof操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变量的值是一个对象或 null，则typeof操作符会像下面例子中所示的那样返回”object”。</p>
<p>虽然在检测<strong>基本数据类型</strong>时 typeof 是非常得力的助手，但在检测<strong>引用类型</strong>的值时，这个操作符的 用处不大。</p>
<p>想知对象的类型，ECMAScript提供了instanceof操作符。语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = variable instanceof constructor</div></pre></td></tr></table></figure></p>
<p>根据规定，所有引用类型的值都是 Object 的实例。因此，==<strong>在检测一个引用类型值和 Object构造函数时，instanceof操作符始终会返回true</strong>==。当然，如果 ==<strong>使用instanceof操作符检测基本类型的值，则该操作符始终会返回false</strong>==,因为基本类型不是对象。</p>
<p><strong>使用typeof操作符检测函数时，该操作符会返回”function”</strong></p>
<h2 id="1-2-执行环境及作用域"><a href="#1-2-执行环境及作用域" class="headerlink" title="1.2 执行环境及作用域"></a>1.2 执行环境及作用域</h2><p><strong>JavaScript 没有块级作用域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">var color = &quot;blue&quot;;</div><div class="line">&#125;</div><div class="line">alert(color);    // &quot;blue&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 10; i++)&#123;</div><div class="line">doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i);      //10</div></pre></td></tr></table></figure>
<h3 id="1-2-1-声明变量"><a href="#1-2-1-声明变量" class="headerlink" title="1.2.1 声明变量"></a>1.2.1 声明变量</h3><p>使用 var 声明的变量会自动被添加到最接近的环境中。如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境。</p>
<p>在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做 法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就 可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p>
<h3 id="1-2-2-查询标识符"><a href="#1-2-2-查询标识符" class="headerlink" title="1.2.2 查询标识符"></a>1.2.2 查询标识符</h3><p>搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到 了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上 搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味 着该变量尚未声明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript变量可以用来保存两种类型的值:<strong>基本类型值和引用类型值</strong>。基本类型的值源自以下5种基本数据类型:<strong>Undefined、Null、Boolean、Number、String和Symbol(ES6)</strong>。基本类型值和引用类型值具 有以下特点:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中;</li>
<li style="list-style: none"><input type="checkbox" checked> 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本;</li>
<li style="list-style: none"><input type="checkbox" checked> 引用类型的值是对象，保存在堆内存中;</li>
<li style="list-style: none"><input type="checkbox" checked> 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;</li>
<li style="list-style: none"><input type="checkbox" checked> 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同<br>一个对象;</li>
<li style="list-style: none"><input type="checkbox" checked> 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。</li>
</ul>
<p>所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执 行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 执行环境有全局执行环境(也称为全局环境)和函数执行环境之分;</li>
<li style="list-style: none"><input type="checkbox" checked> 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链;</li>
<li style="list-style: none"><input type="checkbox" checked> 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全<br>局环境</li>
<li style="list-style: none"><input type="checkbox" checked> 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据;</li>
<li style="list-style: none"><input type="checkbox" checked> 变量的执行环境有助于确定应该何时释放内存。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20171014 js基本概念" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/10/14/20171014 js基本概念/" class="article-date">
      <time datetime="2017-10-14T04:17:51.000Z" itemprop="datePublished">2017-10-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/10/14/20171014 js基本概念/">javascript 基本概念</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 语法 </li>
<li style="list-style: none"><input type="checkbox" checked> 数据类型</li>
<li style="list-style: none"><input type="checkbox" checked> 流控制语句</li>
<li style="list-style: none"><input type="checkbox" checked> 函数<h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2></li>
<li>区分大小写</li>
</ul>
<p>ECMAScript 中的一切(变量、函数名和操作符)都区分大小写，函数名不能使用 typeof，因为它 是一个关键字，但 typeOf 则完全可以是一个有效的函数名。</p>
<ul>
<li>标识符</li>
</ul>
<p>标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符的格式：</p>
<ol>
<li>第一个字符必须是一个字母、下划线(_)或一个美元符号($);</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
<li>按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的<br>首字母大写。</li>
</ol>
<p>==不能把关键字、保留字、true、false 和 null 用作标识符==</p>
<ul>
<li>注释</li>
</ul>
<p>ECMAScript的注释包括单行注释和块级注释。<br>单行注释以两个斜杠开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 单行注释</div></pre></td></tr></table></figure>
<p>块级注释以一个斜杠和一个星号开头，以一个星号和一个斜杠结尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 这是一个多行 </div><div class="line">* (块级)注释 </div><div class="line">*/</div></pre></td></tr></table></figure>
<ul>
<li>严格模式</li>
</ul>
<p>ECMAScript 5 引入了严格模式(strict mode)的概念。严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div></pre></td></tr></table></figure>
<p>在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function doSomething()&#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line">    //函数体 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>语句</li>
</ul>
<p>ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var sum = a + b // 即使没有分号也是有效的语句——不推荐</div><div class="line">var diff = a - b; // 有效的语句——推荐</div></pre></td></tr></table></figure>
<h2 id="1-2-关键字和保留字（了解）"><a href="#1-2-关键字和保留字（了解）" class="headerlink" title="1.2 关键字和保留字（了解）"></a>1.2 关键字和保留字（了解）</h2><p>ECMA描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或 者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。ECMAScript的关键字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>do</th>
<th>instanceof</th>
<th>typeof</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>else</td>
<td>new</td>
<td>var</td>
</tr>
<tr>
<td>catch</td>
<td>finally</td>
<td>return</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>debugger</td>
<td>function</td>
<td>this</td>
<td>with</td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>throw</td>
<td>delete</td>
</tr>
<tr>
<td>in</td>
<td>try</td>
<td>abstract</td>
<td>enum</td>
</tr>
<tr>
<td>int</td>
<td>short</td>
<td>boolean</td>
<td>export</td>
</tr>
<tr>
<td>interface</td>
<td>static</td>
<td>byte</td>
<td>extends</td>
</tr>
<tr>
<td>long</td>
<td>super</td>
<td>char</td>
<td>final</td>
</tr>
<tr>
<td>native</td>
<td>synchronized</td>
<td>class</td>
<td>float</td>
</tr>
<tr>
<td>package</td>
<td>throws</td>
<td>const</td>
<td>goto</td>
</tr>
<tr>
<td>private</td>
<td>transient</td>
<td>debugger</td>
<td>implements</td>
</tr>
<tr>
<td>protected</td>
<td>volatile</td>
<td>double</td>
<td>import</td>
</tr>
<tr>
<td>public</td>
<td></td>
</tr>
</tbody>
</table>
<p>第 5 版把在非严格模式下运行时的保留字缩减为下列这些:</p>
<table>
<thead>
<tr>
<th>class</th>
<th>enum</th>
<th>extends</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>const</td>
<td>export</td>
<td>import</td>
</tr>
</tbody>
</table>
<p>在严格模式下，第 5 版还对以下保留字施加了限制:</p>
<table>
<thead>
<tr>
<th>implements</th>
<th>package</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>interface</td>
<td>private</td>
<td>static</td>
</tr>
<tr>
<td>let</td>
<td>protected</td>
<td>yield</td>
</tr>
</tbody>
</table>
<h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。定义变量时要使用 var 操作符，后跟变量名。</p>
<ul>
<li>全局变量</li>
<li>局部变量<h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2>ECMAScript 中有 6 种简单数据类型(也称为基本数据类型):Undefined、Null、Boolean、Number 、String和Symbol(es6新增一种Symbol)。还有 1 种复杂数据类型——Object。<h3 id="1-4-1-typeof操作符"><a href="#1-4-1-typeof操作符" class="headerlink" title="1.4.1 typeof操作符"></a>1.4.1 typeof操作符</h3></li>
</ul>
<p>检测数据类型的一种方法。</p>
<blockquote>
<p>“undefined”——如果这个值未定义;<br>“boolean”——如果这个值是布尔值;<br>“string”——如果这个值是字符串;<br>“number”——如果这个值是数值;<br>“object”——如果这个值是对象或 null;<br>“function”——如果这个值是函数;<br>“symbol”–如果这个值是Symbol。</p>
</blockquote>
<p>有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回”object”，因为特殊值 null 被认为是一个空的对象引用。</p>
<h3 id="1-4-2-Undefined类型"><a href="#1-4-2-Undefined类型" class="headerlink" title="1.4.2 Undefined类型"></a>1.4.2 Undefined类型</h3><p>Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时,这个变量的值就是 undefined，对于尚未声明过的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型。</p>
<h3 id="1-4-3-Null类型"><a href="#1-4-3-Null类型" class="headerlink" title="1.4.3 Null类型"></a>1.4.3 Null类型</h3><p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因，如下面 的例子所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var car = null;</div><div class="line">alert(typeof car); // &quot;object&quot;</div></pre></td></tr></table></figure>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子 所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (car != null)&#123;</div><div class="line">   // 对 car 对象执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(null == undefined); //true</div></pre></td></tr></table></figure>
<p><strong>如前所述，无论在什么情况下 都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说， 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</strong></p>
<h3 id="1-4-4-Boolean类型"><a href="#1-4-4-Boolean类型" class="headerlink" title="1.4.4 Boolean类型"></a>1.4.4 Boolean类型</h3><p>Boolean类型只有两个字面值:true 和 false。<br>要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()。<br>各种数据类型及其对 应的转换规则：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值(包括无穷大)</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td></td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h3 id="1-4-5-Number类型"><a href="#1-4-5-Number类型" class="headerlink" title="1.4.5 Number类型"></a>1.4.5 Number类型</h3><ol>
<li>浮点数值</li>
</ol>
<p>==0.1 + 0.2 != 0.3==</p>
<p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家;其他使用相同数值格式的语言也存在这个问题。</p>
<ol>
<li>数值范围</li>
</ol>
<p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值。<br>ECMAScript 能够表示的最小数值是 5e-324;最大数值是1.7976931348623157e+308</p>
<p>Infinity/-Infinity</p>
<p>要想确定一个数值是不是有穷的<br>,可以使用 isFinite()函数。</p>
<ol>
<li>NaN</li>
</ol>
<p>NaN，即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数<br>未返回数值的情况(这样就不会抛出错误了)。<br>在 ECMAScript 中，任何数值除以 0 会返回 NaN1，因此不会影响其他代码的执行。NaN 与任何值都不相等，包括 NaN 本身。<br>要想确定一个参数是不是NaN，<br>ECMAScript 定义了 isNaN()函数。</p>
<p><strong>isNaN()也适用于对象。在基于对象调用 isNaN() 函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转 换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。 而这个过程也是 ECMAScript 中内置函数和操作符的一般执行流程。</strong></p>
<ol>
<li>数值转换</li>
</ol>
<p>有3个函数可以把非数值转换为数值:Number()、parseInt()和 parseFloat()。</p>
<p>第一个函数， 即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p>
<blockquote>
<p>Number()函数的转换规则：</p>
</blockquote>
<p>(1). 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</p>
<p>(2). 如果是数字值，只是简单的传入和返回。</p>
<p>(3). 如果是 null 值，返回 0。</p>
<p>(4). 如果是 undefined，返回 NaN。</p>
<p>(5). 如果是字符串，遵循下列规则:</p>
<ul>
<li>如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11(注意:前导的零被忽略了);</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值(同样，也会忽 略前导零);</li>
<li>如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值;</li>
<li>如果字符串是空的(不包含任何字符)，则将其转换为 0;</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li>
</ul>
<p>(6). 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换<br>的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。</p>
<blockquote>
<p>parseInt()函数的转换规则：</p>
</blockquote>
<p><strong>parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN;也就是说，用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如 果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。</strong></p>
<p> parseInt()函数提供第二个参数:转换时使用的基数(即多少进制)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var num1 = parseInt(&quot;10&quot;, 2);   //2 (按二进制解析)</div><div class="line">var num2 = parseInt(&quot;10&quot;, 8);   //8 (按八进制解析)</div><div class="line">var num3 = parseInt(&quot;10&quot;, 10);  //10(按十进制解析)</div><div class="line">var num4 = parseInt(&quot;10&quot;, 16);  //16(按十六进制解析)</div></pre></td></tr></table></figure>
<blockquote>
<p>parseFloat()函数的转换规则：</p>
</blockquote>
<p><strong>parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。</strong></p>
<p>parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导 的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基 数的用法。</p>
<h3 id="1-4-6-String类型"><a href="#1-4-6-String类型" class="headerlink" title="1.4.6 String类型"></a>1.4.6 String类型</h3><p>字符串可以由双<br>引号(“)或单引号(‘)表示。</p>
<p>(1). 字符字面量(转移字符)</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>空格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\</td>
<td>斜杠</td>
</tr>
<tr>
<td>\’</td>
<td>单引号(‘)，在用单引号表示的字符串中使用。例如:’He said, \’hey.\’’</td>
</tr>
<tr>
<td>\”</td>
<td>双引号(“)，在用双引号表示的字符串中使用。例如:”He said, \”hey.\””</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制代码nn表示的一个字符(其中n为0~F)。例如，\x41表示”A”</td>
</tr>
<tr>
<td>\unnnn</td>
<td>　以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如，\u03a3表示希腊字符Σ</td>
</tr>
</tbody>
</table>
<p>(２). 转化为字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">toString();</div><div class="line"></div><div class="line">String();</div></pre></td></tr></table></figure>
<blockquote>
<p>toString();</p>
</blockquote>
<p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法，这个方法唯一要做的就是返回相应值的字符串表现。</p>
<p>==数值、布尔值、对象和字符串值都有 toString()方法。但 null 和 undefined 值没有这个方法。==<br>多数情况下，调用 toString()方法不必传递参数。但是，在调用数值的 toString()方法时，可 以传递一个参数:输出数值的基数。toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式表示的字符串值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString());   // &quot;10&quot;</div><div class="line">alert(num.toString(2));  // &quot;1010&quot;</div><div class="line">alert(num.toString(8));  // &quot;12&quot;</div><div class="line">alert(num.toString(10)); // &quot;10&quot;</div><div class="line">alert(num.toString(16)); // &quot;a&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>String();</p>
</blockquote>
<p>在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String()函数转换规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果值是 null，则返回”null”;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果值是 undefined，则返回”undefined”。</li>
</ul>
<h3 id="1-4-7-Object类型"><a href="#1-4-7-Object类型" class="headerlink" title="1.4.7 Object类型"></a>1.4.7 Object类型</h3><p><strong>ECMAScript中的对象其实就是一组数据和功能的集合。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div></pre></td></tr></table></figure></p>
<p>如果不给构造函数传递参数，则可以省略后面的那一对圆括号(不推荐)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object;  //有效，但不推荐省略圆括号</div></pre></td></tr></table></figure></p>
<p><strong>Object 的每个实例都具有下列属性和方法:</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 8 就是 Object()。</li>
<li style="list-style: none"><input type="checkbox" checked> hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定(例 如:o.hasOwnProperty(“name”))。</li>
<li style="list-style: none"><input type="checkbox" checked> isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。</li>
<li style="list-style: none"><input type="checkbox" checked> propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li style="list-style: none"><input type="checkbox" checked> toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li style="list-style: none"><input type="checkbox" checked> toString():返回对象的字符串表示。</li>
<li style="list-style: none"><input type="checkbox" checked> valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</li>
</ul>
<p>由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。</p>
<h2 id="1-5-操作符"><a href="#1-5-操作符" class="headerlink" title="1.5 操作符"></a>1.5 操作符</h2><p>ECMA 描述了一组用于操作数据值的操作符，包括<strong>算术操作符</strong>(如加号和减号)、<strong>位操作符</strong>、<strong>关系操作符</strong>和<strong>相等操作符</strong>。==在应用于对象时，相应的操作符通常都会调用对象的valueOf()和(或)toString()方法，以便取得可以操作的值==。</p>
<h3 id="1-5-1-一元操作符"><a href="#1-5-1-一元操作符" class="headerlink" title="1.5.1 一元操作符"></a>1.5.1 一元操作符</h3><p>只能操作一个值的操作符叫做一元操作符。</p>
<p>(1). 递增和递减操作符</p>
<p>前置递减/后置递减 or 前置递增/后置递增</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++1 、 1++  区别(先自加后运算、先运算后自加)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--1 、 1--   区别(先自加后运算、先运算后自减)</div></pre></td></tr></table></figure>
<p>(2). 一元加和减操作符(略)</p>
<h3 id="1-5-2-位操作符（略）"><a href="#1-5-2-位操作符（略）" class="headerlink" title="1.5.2 位操作符（略）"></a>1.5.2 位操作符（略）</h3><h3 id="1-5-3-布尔操作符"><a href="#1-5-3-布尔操作符" class="headerlink" title="1.5.3 布尔操作符"></a>1.5.3 布尔操作符</h3><p>==布尔操作符一共有 3 个:非!(NOT)、与&amp;&amp;(AND) 和或||(OR)。==</p>
<h4 id="1-逻辑非"><a href="#1-逻辑非" class="headerlink" title="1. 逻辑非"></a>1. 逻辑非</h4><p>逻辑非操作符由一个叹号(!)表示。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反，逻辑非操作符遵循下列规则：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是一个对象，返回 false;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是一个空字符串，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是一个非空字符串，返回 false;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是数值 0，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是任意非 0 数值(包括 Infinity)，返回 false;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是 null，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是 NaN，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是 undefined，返回 true。</li>
</ul>
<h4 id="2-逻辑与"><a href="#2-逻辑与" class="headerlink" title="2. 逻辑与"></a>2. 逻辑与</h4><p>逻辑与操作符由两个和号(&amp;&amp;)表示，有两个操作数。</p>
<p>两个操作数都是布尔值（略）。</p>
<p>有一个操作数不是布尔值遵循下列规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果第一个操作数是对象，则返回第二个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是对象，则返回第二个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 null，则返回 null;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则返回 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 undefined，则返回 undefined。</li>
</ul>
<p><strong>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。</strong></p>
<h4 id="3-逻辑或"><a href="#3-逻辑或" class="headerlink" title="3. 逻辑或"></a>3. 逻辑或</h4><p>逻辑或操作符由两个竖线符号(||)表示，有两个操作数，</p>
<p>两个操作数都是布尔值（略）。</p>
<p>有一个操作数不是布尔值遵循下列规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果第一个操作数是对象，则返回第一个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果第一个操作数的求值结果为 false，则返回第二个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是对象，则返回第一个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是 null，则返回 null;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是 NaN，则返回 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是 undefined，则返回 undefined。</li>
</ul>
<p><strong>与逻辑与操作符相似，逻辑或操作符也是短路操作符。</strong></p>
<h3 id="1-5-4-乘性操作符"><a href="#1-5-4-乘性操作符" class="headerlink" title="1.5.4 乘性操作符"></a>1.5.4 乘性操作符</h3><p>3个乘性操作符:乘法、除法和求模</p>
<p>乘法、除法(省略)</p>
<p>求模：求模操作符会遵循下列特殊规则来处理特殊的值:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数都是数值，执行常规的除法计算，返回除得的余数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是有限大的数值而除数是零，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 被 Infinity 除，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是零，则结果是零;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
<h3 id="1-5-5-加性操作符"><a href="#1-5-5-加性操作符" class="headerlink" title="1.5.5 加性操作符"></a>1.5.5 加性操作符</h3><h4 id="1-加法"><a href="#1-加法" class="headerlink" title="1. 加法"></a>1. 加法</h4><p>如果==两个操作符都是数值==，执行常规的加法计算，然后根据下列规则返回结果:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 加 Infinity，则结果是 Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是-Infinity 加-Infinity，则结果是-Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 加-Infinity，则结果是 NaN;</li>
</ul>
<p>如果==有一个操作数是字符串==，那么就要应用如下规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接<br>起来。</li>
</ul>
<p>如果==有一个操作数是对象、数值或布尔值==，则调用它们的 toString()方法取得相应的字符串值，<br>然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串”undefined”和”null”。</p>
<h4 id="2-减法"><a href="#2-减法" class="headerlink" title="2. 减法"></a>2. 减法</h4><p>减法操作符运算规则：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 减 Infinity，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是-Infinity 减-Infinity，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 减-Infinity，则结果是 Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是-Infinity 减 Infinity，则结果是-Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将<br>其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果<br>就是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到<br>的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()<br>方法并将得到的字符串转换为数值。<h3 id="1-5-6-关系操作符"><a href="#1-5-6-关系操作符" class="headerlink" title="1.5.6 关系操作符"></a>1.5.6 关系操作符</h3>小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)，运算规则：</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是数值，则执行数值比较。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执<br>行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面<br>的规则执行比较。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<p>==常见的奇怪的现象：==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var result = &quot;Brick&quot; &lt; &quot;alphabet&quot;;    //true</div><div class="line"></div><div class="line">var result = &quot;23&quot; &lt; &quot;3&quot;;    //true</div><div class="line"></div><div class="line">var result = &quot;23&quot; &lt; 3;    //false</div><div class="line"></div><div class="line">var result = &quot;a&quot; &lt; 3; // false，因为&quot;a&quot;被转换成了 NaN</div><div class="line"></div><div class="line">var result1 = NaN &lt; 3; //false</div><div class="line"></div><div class="line">var result2 = NaN &gt;= 3; //false</div></pre></td></tr></table></figure></p>
<p>==<strong>根据规则，任何操作数与 NaN 进行关系比较，结果都是 false。</strong>==</p>
<h3 id="1-5-7-相等操作符"><a href="#1-5-7-相等操作符" class="headerlink" title="1.5.7 相等操作符"></a>1.5.7 相等操作符</h3><h4 id="1-相等和不相等"><a href="#1-相等和不相等" class="headerlink" title="1. 相等和不相等"></a>1. 相等和不相等</h4><p>运算规则：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而<br>true 转换为 1;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类<br>型值按照前面的规则进行比较;</li>
<li style="list-style: none"><input type="checkbox" checked> null 和 undefined 是相等的。</li>
<li style="list-style: none"><input type="checkbox" checked> 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示:<br>即使两个操作数都是 NaN，相等操作符也返回 false;因为按照规则，NaN 不等于 NaN。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，<br>则相等操作符返回 true;否则，返回 false。<h4 id="2-全等和不全等-略"><a href="#2-全等和不全等-略" class="headerlink" title="2. 全等和不全等(略)"></a>2. 全等和不全等(略)</h4><h3 id="1-5-8-逗号操作符"><a href="#1-5-8-逗号操作符" class="headerlink" title="1.5.8 逗号操作符"></a>1.5.8 逗号操作符</h3>使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num1=1, num2=2, num3=3;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>逗号操作符多用于声明多个变量;但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号 操作符总会返回表达式中的最后一项，如下面的例子所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = (5, 1, 4, 8, 0); // num的值为0</div></pre></td></tr></table></figure></p>
<h2 id="1-6-语句"><a href="#1-6-语句" class="headerlink" title="1.6 语句"></a>1.6 语句</h2><h3 id="1-6-1-if语句-略"><a href="#1-6-1-if语句-略" class="headerlink" title="1.6.1 if语句(略)"></a>1.6.1 if语句(略)</h3><h3 id="1-6-2-do-while语句-略"><a href="#1-6-2-do-while语句-略" class="headerlink" title="1.6.2 do-while语句(略)"></a>1.6.2 do-while语句(略)</h3><p>do-while 语句是一种后测试循环语句，循环体内的代码至少会被执行一次</p>
<h3 id="1-6-3-while语句-略"><a href="#1-6-3-while语句-略" class="headerlink" title="1.6.3 while语句(略)"></a>1.6.3 while语句(略)</h3><h3 id="1-6-4-for语句-略"><a href="#1-6-4-for语句-略" class="headerlink" title="1.6.4 for语句(略)"></a>1.6.4 for语句(略)</h3><h3 id="1-6-5-for-in语句"><a href="#1-6-5-for-in语句" class="headerlink" title="1.6.5 for-in语句"></a>1.6.5 for-in语句</h3><p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (property in expression) statement</div></pre></td></tr></table></figure></p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var propName in window) &#123;</div><div class="line">     document.write(propName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-6-6-break和continue语句"><a href="#1-6-6-break和continue语句" class="headerlink" title="1.6.6 break和continue语句"></a>1.6.6 break和continue语句</h3><p>==break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环， 强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。==</p>
<h3 id="1-6-7-switch语句"><a href="#1-6-7-switch语句" class="headerlink" title="1.6.7 switch语句"></a>1.6.7 switch语句</h3><p>switch语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">switch (expression) &#123;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      default: statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果合并多个case，添加注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">switch (i) &#123;</div><div class="line">    case 25:</div><div class="line">        /* 合并两种情形 */ </div><div class="line">    case 35:</div><div class="line">        alert(&quot;25 or 35&quot;);</div><div class="line">        break;</div><div class="line">    case 45:</div><div class="line">        alert(&quot;45&quot;);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        alert(&quot;Other&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h2><p>函数的基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function functionName(arg0, arg1,...,argN) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>严格模式对函数有一些限制:</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 不能把函数命名为 eval 或 arguments;</li>
<li style="list-style: none"><input type="checkbox" checked> 不能把参数命名为 eval 或 arguments;</li>
<li style="list-style: none"><input type="checkbox" checked> 不能出现两个命名参数同名的情况。<h3 id="1-7-1-理解函数参数"><a href="#1-7-1-理解函数参数" class="headerlink" title="1.7.1 理解函数参数"></a>1.7.1 理解函数参数</h3>ECMAScript 中的参数在内部是用一个类数组来表示的，<br>可以使用方括号语法访问它的每一个元素，例如arguments[0]，也可以用length属性来确定传递进来多少个参数<h3 id="1-7-2-没有重载"><a href="#1-7-2-没有重载" class="headerlink" title="1.7.2 没有重载"></a>1.7.2 没有重载</h3>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言(如 Java)中，可以为一个函数 编写两个定义，只要这两个定义的签名(接受的参数的类型和数量)不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可 能做到的。<br><strong>通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</strong></li>
</ul>
<h2 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h2><p>ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。</p>
<p>以下简要总结了 ECMAScript 中基本的要素：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript中的<strong>基本数据类型</strong>包括 Undefined、Null、Boolean、Number、String和Symbol(ES6新增)</li>
<li style="list-style: none"><input type="checkbox" checked> 与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型，Number 类型可<br>用于表示所有数值。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript中也有一种<strong>复杂的数据类型</strong>，即 Object类型，该类型是这门语言中所有对象的基<br>础类型。</li>
<li style="list-style: none"><input type="checkbox" checked> 严格模式为这门语言中容易出错的地方施加了限制。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript 提供了很多与C及其他类 C语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript从其他语言中借鉴了很多流控制语句，例如if语句、for语句和switch语句等。ECMAScript中的函数与其他语言中的函数有诸多不同之处。</li>
<li style="list-style: none"><input type="checkbox" checked> 无须指定函数的返回值，因为任何 ECMAScript函数都可以在任何时候返回任何值。</li>
<li style="list-style: none"><input type="checkbox" checked> 实际上，未指定返回值的函数返回的是一个特殊的 undefined值。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的</li>
<li style="list-style: none"><input type="checkbox" checked> 可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数</li>
<li style="list-style: none"><input type="checkbox" checked> 由于不存在函数签名的特性，ECMAScript 函数不能重载。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20170921 js组成" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/09/17/20170921 js组成/" class="article-date">
      <time datetime="2017-09-17T12:56:29.000Z" itemprop="datePublished">2017-09-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/09/17/20170921 js组成/">javascript 组成</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="js的组成"><a href="#js的组成" class="headerlink" title="js的组成"></a>js的组成</h1><ul>
<li><strong>核心(ECMAScript):++提供核心语言功能++</strong></li>
<li><strong>文档对象模型(DOM):++提供访问和操作网页内容的方法和接口++</strong></li>
<li><strong>浏览器对象模型(BOM):++提供与浏览器交互的方法和接口++</strong><h2 id="1-1-ECMAScript"><a href="#1-1-ECMAScript" class="headerlink" title="1.1 ECMAScript"></a>1.1 ECMAScript</h2>ECMAScript 与 Web 浏览器没有依赖关系，这门语言本身并不包含输入和输出定义。Web 浏览器只是 ECMAScript 实现可能的<strong>宿主环境</strong>之一。这门语言的组成部分:</li>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象<h2 id="1-2-文档对象模型-DOM"><a href="#1-2-文档对象模型-DOM" class="headerlink" title="1.2 文档对象模型(DOM)"></a>1.2 文档对象模型(DOM)</h2>文档对象模型(DOM，Document Object Model)是针对 XML 但经过扩展用于 HTML 的应用程序编 程接口(API，Application Programming Interface)。DOM 把整个页面映射为一个多层节点结构。HTML 7 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。<strong>DOM 并不只是针对 JavaScript 的</strong>，很多别的语言也都实现了 DOM。 不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这 门语言的一个重要组成部分。DOM 级别：</li>
<li>DOM1</li>
<li>DOM2</li>
<li>DOM3<h2 id="1-3-浏览器对象模型-BOM"><a href="#1-3-浏览器对象模型-BOM" class="headerlink" title="1.3 浏览器对象模型(BOM)"></a>1.3 浏览器对象模型(BOM)</h2>浏览器对象模型(BOM，Browser Object Model)，从根本上讲，BOM 只处理浏览器窗口和框架;但人们习惯上也把所有针对浏览器的 JavaScript 扩展 算作 BOM 的一部分。下面就是一些这样的扩展:</li>
<li>弹出新浏览器窗口的功能;</li>
<li>移动、缩放和关闭浏览器窗口的功能;</li>
<li>提供浏览器详细信息的 navigator 对象;</li>
<li>提供浏览器所加载页面的详细信息的 location 对象;</li>
<li>提供用户显示器分辨率详细信息的 screen 对象;</li>
<li>对 cookies 的支持;</li>
<li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li>
</ul>
<p>由于没有 BOM 标准可以遵循，因此每个浏览器都有自己的实现。现在有了 HTML5，BOM 实现的细节有望朝着兼容性越来越高的方向发展。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 Lucien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/blog/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
             title: "a.article-title, .article-more-link a", 
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>