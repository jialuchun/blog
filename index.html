<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Lucien" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="Blogs Of Lucien">
<meta property="og:url" content="https://github.com/jialuchun/blog/index.html">
<meta property="og:site_name" content="Blogs Of Lucien">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blogs Of Lucien">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Blogs Of Lucien" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/blog/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Blogs Of Lucien</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/blog/" class="profilepic">
            <img src="http://mamaj-oss-ws.oss-cn-beijing.aliyuncs.com/free/Jia/luchun/photo.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/blog/">Lucien</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/blog/archives/">主页</a></li>
                        
                            <li><a href="/blog/archives/">所有文章</a></li>
                        
                            <li><a href="/blog/tags/">标签云</a></li>
                        
                            <li><a href="/blog/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/blog/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lucien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/blog/" class="profilepic">
                <img src="http://mamaj-oss-ws.oss-cn-beijing.aliyuncs.com/free/Jia/luchun/photo.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/blog/" title="回到主页">Lucien</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/blog/archives/">主页</a></li>
                
                    <li><a href="/blog/archives/">所有文章</a></li>
                
                    <li><a href="/blog/tags/">标签云</a></li>
                
                    <li><a href="/blog/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/blog/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-20171128 js引用类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/11/28/20171128 js引用类型/" class="article-date">
      <time datetime="2017-11-28T12:31:49.000Z" itemprop="datePublished">2017-11-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/11/28/20171128 js引用类型/">js 引用类型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 使用对象</li>
<li style="list-style: none"><input type="checkbox" checked> 创建并操作数组</li>
<li style="list-style: none"><input type="checkbox" checked> 理解基本的JavaScript类型</li>
<li style="list-style: none"><input type="checkbox" checked> 使用基本类型和基本包装类型<h2 id="1-1-Object类型"><a href="#1-1-Object类型" class="headerlink" title="1.1 Object类型"></a>1.1 Object类型</h2>==创建Object实例的方式有两种==。</li>
<li><p>第一种是使用 new 操作符后跟 Object 构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
</li>
<li><p>另一种方式是使用对象字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name : &quot;Nicholas&quot;,</div><div class="line">    age : 29</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-2-Array类型"><a href="#1-2-Array类型" class="headerlink" title="1.2 Array类型"></a>1.2 Array类型</h2><p>==创建数组的基本方式有两种==。</p>
<ul>
<li><p>第一种是使用Array构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = new Array();</div><div class="line">var colors = new Array(20);</div><div class="line">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">var colors = Array(3); // 创建一个包含 3 项的数组</div><div class="line">var names = Array(&quot;Greg&quot;); // 创建一个包含 1 项，即字符串&quot;Greg&quot;的数组</div></pre></td></tr></table></figure>
</li>
<li><p>使用数组字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</div><div class="line">var names = []; // 创建一个空数组</div><div class="line">var values = [1,2,]; // 不要这样!这样会创建一个包含 2 或 3 项的数组</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-1-检测数组"><a href="#1-2-1-检测数组" class="headerlink" title="1.2.1 检测数组"></a>1.2.1 检测数组</h3><ul>
<li>instanceof 操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (value instanceof Array)&#123;    </div><div class="line">    //对数组执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实 际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自 不同的构造函数。</p>
<ul>
<li>Array.isArray()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (Array.isArray(value))&#123; </div><div class="line">    //对数组执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<h3 id="1-2-2-转换方法"><a href="#1-2-2-转换方法" class="headerlink" title="1.2.2 转换方法"></a>1.2.2 转换方法</h3><p>所有对象都具有toLocaleString()、toString()和 valueOf()方法。</p>
<ul>
<li>调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</li>
<li>valueOf()返回的还是数组</li>
</ul>
<p>数组继承的toLocaleString()、toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 join()方法，则可以使用不同的分隔符来构建这个字符串。</p>
<h3 id="1-2-3-栈方法"><a href="#1-2-3-栈方法" class="headerlink" title="1.2.3 栈方法"></a>1.2.3 栈方法</h3><p>栈是一种LIFO(Last-In-First-Out，后进先出)的数据结构，也就是最新添加的项最早被移除。</p>
<p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。</p>
<ul>
<li>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并==返回修改后数组的长度==。</li>
<li>pop()方法则从数组末尾移除最后一项，减少数组的 length值，然后==返回移除的项==。<h3 id="1-2-4-队列方法"><a href="#1-2-4-队列方法" class="headerlink" title="1.2.4 队列方法"></a>1.2.4 队列方法</h3>队列数据结构的访问规则是FIFO(First-In-First-Out， 先进先出)。</li>
</ul>
<p>结合使用 shift()和push()方法，可以像使 用队列一样使用数组。</p>
<p>同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p>
<h3 id="1-2-5-重排序方法"><a href="#1-2-5-重排序方法" class="headerlink" title="1.2.5 重排序方法"></a>1.2.5 重排序方法</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> reverse()</li>
<li>reverse()方法会反转数组项的顺序</li>
<li style="list-style: none"><input type="checkbox" checked> sort()</li>
<li>sort()方法按升序排列数组项。</li>
<li>sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。这种排序方式在很多情况下都不是最佳方案。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0, 1, 5, 10, 15];</div><div class="line">values.sort();</div><div class="line">alert(values);     //0,1,10,15,5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>==解决排序方案：==<br>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。</p>
<p>该比较函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b，其返回值如下：</p>
<ul>
<li>若a小于b，在排序后的数组中a应该出现在 b 之前，则返回一个小于0的值。</li>
<li>若a等于b，则返回 0。</li>
<li>若a大于b，则返回一个大于0的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">    if (value1 &lt; value2) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125; else if (value1 &gt; value2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort()方法即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0, 1, 5, 10, 15];</div><div class="line">values.sort(compare);</div><div class="line">alert(values); //0,1,5,10,15</div></pre></td></tr></table></figure></p>
<p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2)&#123;</div><div class="line">    return value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-6-操作方法"><a href="#1-2-6-操作方法" class="headerlink" title="1.2.6 操作方法"></a>1.2.6 操作方法</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> concat()</li>
<li>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。</li>
<li style="list-style: none"><input type="checkbox" checked> slice()</li>
<li>它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项— —==<strong>但不包括结束位置的项</strong>==。注意，==slice()方法不会影响原始数组==。</li>
<li><p>如果结束位置小于起始位置，则返回空数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</div><div class="line">var colors2 = colors.slice(1);</div><div class="line">var colors3 = colors.slice(1,4);</div><div class="line">alert(colors2);   //green,blue,yellow,purple</div><div class="line">alert(colors3);   //green,blue,yellow</div></pre></td></tr></table></figure>
</li>
<li><p>[x] splice()</p>
</li>
<li>splice()的主要用途是向数组的中部插入项：删除、插入、替换</li>
<li><strong>删除</strong>:可以删除任意数量的项，只需指定2个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项。</li>
<li><strong>插入</strong>:可以向指定位置插入任意数量的项，只需提供 3个参数:起始位置、0(要删除的项数)和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li><strong>替换</strong>:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”。</li>
<li>==splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)。==</li>
<li>示例代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</div><div class="line">var removed = colors.splice(0,1);   // 删除第一项</div><div class="line">alert(colors); // green,blue </div><div class="line">alert(removed);//red，返回的数组中只包含一项</div><div class="line"></div><div class="line"></div><div class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置 1 开始插入两项</div><div class="line">alert(colors); // green,yellow,orange,blue</div><div class="line">alert(removed); // 返回的是一个空数组</div><div class="line"></div><div class="line"></div><div class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两项，删除一项</div><div class="line">alert(colors);  //green,red,purple,orange,blue</div><div class="line">alert(removed); //yellow，返回的数组中只包含一项</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-7-位置方法"><a href="#1-2-7-位置方法" class="headerlink" title="1.2.7 位置方法"></a>1.2.7 位置方法</h3><p>indexOf()和 lastIndexOf()。这两个方法都接收两个参数:要查找的项和(可选的)表示查找起点位置的索引。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1</p>
<p>在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> indexOf()</li>
<li>indexOf()方法从数组的开头(位置0)开始向后查找</li>
<li style="list-style: none"><input type="checkbox" checked> lastIndexOf()</li>
<li>lastIndexOf()方法可返回一个指定的字符串值==最后出现的位置==，在一个字符串中的指定位置从后向前搜索。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">alert(numbers.indexOf(4));  //3</div><div class="line">alert(numbers.lastIndexOf(4)); //5</div><div class="line">alert(numbers.indexOf(4, 4));     //5</div><div class="line">alert(numbers.lastIndexOf(4, 4)); //3</div><div class="line"></div><div class="line">var person = &#123; name: &quot;Nicholas&quot; &#125;;</div><div class="line">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</div><div class="line">var morePeople = [person];</div><div class="line">alert(people.indexOf(person));     //-1</div><div class="line">alert(morePeople.indexOf(person)); //0</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-8-迭代方法"><a href="#1-2-8-迭代方法" class="headerlink" title="1.2.8 迭代方法"></a>1.2.8 迭代方法</h3><p><strong>以下方法都不会修改数组中的包含的值。</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> every()</li>
<li>every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true</li>
<li style="list-style: none"><input type="checkbox" checked> some()</li>
<li>some():对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</li>
<li style="list-style: none"><input type="checkbox" checked> filter()</li>
<li>filter():对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li style="list-style: none"><input type="checkbox" checked> forEach()</li>
<li>forEach():对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li style="list-style: none"><input type="checkbox" checked> map()</li>
<li>map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
</ul>
<p>==every()、some()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.every(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">alert(everyResult); //false</div><div class="line"></div><div class="line">var someResult = numbers.some(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">alert(someResult); //true</div></pre></td></tr></table></figure></p>
<p>==filter()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var filterResult = numbers.filter(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">alert(filterResult);    //[3,4,5,4,3]</div></pre></td></tr></table></figure></p>
<p>==map()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var mapResult = numbers.map(function(item, index, array)&#123;</div><div class="line">    return item * 2;</div><div class="line">&#125;);</div><div class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</div></pre></td></tr></table></figure></p>
<p>==forEach()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">numbers.forEach(function(item, index, array)&#123;</div><div class="line">    //执行某些操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="1-2-9归并方法"><a href="#1-2-9归并方法" class="headerlink" title="1.2.9归并方法"></a>1.2.9归并方法</h3><p>这两个方法都接收两个参数:一个在每一项上调用的函数和(可选的)作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收4 个参数:前一个值、当前值、项的索引和数组对象。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> reduce()</li>
<li>reduce()方法从数组的第一项开始，逐个遍历到最后</li>
<li style="list-style: none"><input type="checkbox" checked> reduceRight()</li>
<li>reduceRight()则从数组的最后一项开始，向前遍历到第一项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var values = [1,2,3,4,5];</div><div class="line">var sum = values.reduce(function(prev, cur, index, array)&#123;</div><div class="line">    return prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); //15</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一次执行回调函数，prev 是 1，cur 是 2。第二次，prev 是 3(1 加 2 的结果)，cur 是 3(数组 的第三项)。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。<br>reduceRight()的作用类似，只不过方向相反而已。</p>
<h2 id="1-3-Date类型"><a href="#1-3-Date类型" class="headerlink" title="1.3 Date类型"></a>1.3 Date类型</h2><p>常用的日期方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Date(); // 返回当日的日期和时间。</div><div class="line">Data.now();//返回表示调用这个方法时的日期和时间的毫秒数</div><div class="line">var myDate=new Date();  //创建日期对象</div><div class="line">getTime();//返回 1970 年 1 月 1 日至今的毫秒数。</div><div class="line">getFullYear();//从 Date 对象以四位数字返回年份。</div><div class="line">getMonth();//从 Date 对象返回月份 (0 ~ 11)。</div><div class="line">getDate();//从 Date 对象返回一个月中的某一天 (1 ~ 31)。</div><div class="line">getDay();//从 Date 对象返回一周中的某一天 (0 ~ 6)。</div><div class="line">getHours();//返回 Date 对象的小时 (0 ~ 23)。</div><div class="line">getMinutes();//返回 Date 对象的分钟 (0 ~ 59)。</div><div class="line">getSeconds();//返回 Date 对象的秒数 (0 ~ 59)。</div></pre></td></tr></table></figure></p>
<h2 id="1-4-RegExp类型"><a href="#1-4-RegExp类型" class="headerlink" title="1.4 RegExp类型"></a>1.4 RegExp类型</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 字面量形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags ; //语法</div></pre></td></tr></table></figure>
</li>
</ul>
<p>模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。</p>
<p>每个正则表达式都可带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志。</p>
<ul>
<li>g:表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止;</li>
<li>i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写;</li>
<li>m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*匹配字符串中所有&quot;at&quot;的实例</div><div class="line">*/</div><div class="line">var pattern1 = /at/g; </div><div class="line"></div><div class="line">/*</div><div class="line">*匹配第一个&quot;bat&quot;或“cat”，不区分大小写</div><div class="line">*/</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">/* 10 </div><div class="line">* 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写</div><div class="line">*/</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与其他语言中的正则表达式类似，<strong>模式中使用的所有元字符都必须转义</strong>。正则表达式中的元字符包括:==( [ { \ ^ $ | ) ? * + .]}==</p>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*匹配第一个“bat”或“cat”，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配第一个&quot; [bc]at&quot;，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern2 = /\[bc\]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern3 = /.at/gi;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配所有&quot;.at&quot;，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern4 = /\.at/gi;</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> RegExp构造函数形式</li>
</ul>
<p>它接收两个参数:一个是要匹配的字符串模式，另一个是可选的标志字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> RegExp实例方法</li>
<li>exec()</li>
<li>test()<h2 id="1-5-Function类型"><a href="#1-5-Function类型" class="headerlink" title="1.5 Function类型"></a>1.5 Function类型</h2><strong>每个函数都是 Function 类型的实例</strong>，而且都与其他引用类型一样具有属性和方法。<h3 id="1-5-1-函数声明与函数表达式"><a href="#1-5-1-函数声明与函数表达式" class="headerlink" title="1.5.1 函数声明与函数表达式"></a>1.5.1 函数声明与函数表达式</h3>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问);至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。<h3 id="1-5-2-作为值的函数"><a href="#1-5-2-作为值的函数" class="headerlink" title="1.5.2 作为值的函数"></a>1.5.2 作为值的函数</h3>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function callSomeFunction(someFunction,someArgument)&#123;</div><div class="line">    return someFunction(someArgument);</div><div class="line">&#125;</div><div class="line">function add10(num)&#123;</div><div class="line">    return num + 10;</div><div class="line">&#125;</div><div class="line">var result1 = callSomeFunction(add10, 10);</div><div class="line">alert(result1);   //20</div><div class="line"></div><div class="line">function getGreeting(name)&#123;</div><div class="line">    return &quot;Hello, &quot; + name;</div><div class="line">&#125;</div><div class="line">var result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);</div><div class="line">alert(result2);   //&quot;Hello, Nicholas&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。</p>
<h3 id="1-5-3-函数内部属性"><a href="#1-5-3-函数内部属性" class="headerlink" title="1.5.3 函数内部属性"></a>1.5.3 函数内部属性</h3><p>在函数内部，有两个特殊的对象:arguments 和 this。<br>虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if (num &lt;=1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num-1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义阶乘函数一般都要用到递归算法;如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if (num &lt;=1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num-1)</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个重写后的factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var trueFactorial = factorial;</div><div class="line">factorial = function()&#123;</div><div class="line">    return 0;</div><div class="line">&#125;;</div><div class="line">alert(trueFactorial(5));     //120</div><div class="line">alert(factorial(5));         //0</div></pre></td></tr></table></figure></p>
<p>在此，变量 trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的 factorial() 那样不使用arguments.callee，调用 trueFactorial()就会返回0。可是，在解除了函数体内的代 码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘;至于factorial()，它现在只是一个返回 0 的函数。</p>
<p>this 引用的是函数据以执行的环境对象——或者也可以说是 this 值(当在网页的全局作用域中调用函数时， this 对象引用的就是 window)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor();     //&quot;red&quot;</div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();   //&quot;blue&quot;</div></pre></td></tr></table></figure></p>
<h3 id="1-5-4-函数属性和方法"><a href="#1-5-4-函数属性和方法" class="headerlink" title="1.5.4 函数属性和方法"></a>1.5.4 函数属性和方法</h3><p>每个函数都包含两个属性:length和prototype。其中，length 属性表示函数希望接收的命名参数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum.length);   //2</div></pre></td></tr></table></figure></p>
<p>prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访 问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的。在ECMAScript5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法:apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p>
<p><strong>call()方法与apply()方法的作用相同，它们的区别仅在于</strong>接收参数的方式不同。对于call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">function callSum(num1, num2)&#123;</div><div class="line">    return sum.call(this, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(10,10));   //20</div></pre></td></tr></table></figure></p>
<p>在使用 call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用 apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。 如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply() 肯定更方便;否则，选择 call()可能更合适。</p>
<p>传递参数并非 apply()和call()真正的用武之地;<strong>它们真正强大的地方是能够扩充函数赖以运行的作用域。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor(); //red</div><div class="line">sayColor.call(this); //red</div><div class="line">sayColor.call(window); //red</div><div class="line">sayColor.call(o); //blue</div></pre></td></tr></table></figure></p>
<p>ECMAScript 5 还定义了一个方法:bind()。这个方法会创建一个函数的实例，其 this 值会被绑 定到传给 bind()函数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">var objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor();    //blue</div></pre></td></tr></table></figure></p>
<h3 id="1-5-6-基本包装类型"><a href="#1-5-6-基本包装类型" class="headerlink" title="1.5.6 基本包装类型"></a>1.5.6 基本包装类型</h3><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型:Boolean、Number 和 String。</p>
<p>==每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s2; // &quot;me text&quot;</div></pre></td></tr></table></figure></p>
<p>基本类型值不是对象，因而从逻辑上讲它们不应该有方法。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 创建 String 类型的一个实例;</li>
<li style="list-style: none"><input type="checkbox" checked> 在实例上调用指定的方法;</li>
<li style="list-style: none"><input type="checkbox" checked> 销毁这个实例。</li>
</ul>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = new String(&quot;some text&quot;);</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s1 = null;</div></pre></td></tr></table></figure></p>
<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</strong>。来看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">alert(s1.color);   //undefined</div></pre></td></tr></table></figure></p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>Boolean 类型的实例重写了valueOf()方法，返回基本类型值 true 或 false;重写了 toString() 方法，返回字符串”true”和”false”。可是，Boolean 对象在 ECMAScript 中的用处不大，因为它经 常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var falseObject = new Boolean(false);</div><div class="line">var result = falseObject &amp;&amp; true;</div><div class="line">alert(result);  //true</div><div class="line"></div><div class="line">var falseValue = false;</div><div class="line">result = falseValue &amp;&amp; true;</div><div class="line">alert(result);  //false</div></pre></td></tr></table></figure></p>
<p>基本类型与引用类型的布尔值还有两个区别。首先，typeof 操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是 Boolean 类型的实例，所以使用instanceof操作符测试 Boolean对象会返回true，而测试基本类型的布尔值则返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(typeoffalseObject); //object</div><div class="line">alert(typeof falseValue); //boolean</div><div class="line">alert(falseObject instanceof Boolean);//true</div><div class="line">alert(falseValue instanceof Boolean);//false</div></pre></td></tr></table></figure></p>
<p><strong>建议是永远不要使 用 Boolean 对象。</strong></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>Number 类型也重写了valueOf()、toLocaleString()和 toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。</p>
<p>可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString()); //&quot;10&quot;</div><div class="line">alert(num.toString(2)); //&quot;1010&quot;</div><div class="line">alert(num.toString(8)); //&quot;12&quot;</div><div class="line">alert(num.toString(10)); //&quot;10&quot;</div><div class="line">alert(num.toString(16)); //&quot;a&quot;</div></pre></td></tr></table></figure></p>
<p>除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toFixed(2));  //&quot;10.00&quot;</div></pre></td></tr></table></figure></p>
<p>我们仍 然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用 typeof 和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocale- String()和 toString()方法，都返回对象所表示的基本字符串值。</p>
<p>String 类型的每个实例都有一个length属性，表示字符串中包含多个字符。</p>
<p>String 类型提供了很多方法，用于辅助完成对 ECMAScript中字符串的解析和操作.</p>
<h5 id="1-字符方法"><a href="#1-字符方法" class="headerlink" title="1. 字符方法"></a>1. 字符方法</h5><p>两个用于访问字符串中特定字符的方法是:charAt()和 charCodeAt()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charAt(1));   //&quot;e&quot;</div><div class="line"></div><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charCodeAt(1));//输出&quot;101&quot;</div></pre></td></tr></table></figure></p>
<h5 id="2-字符串操作方法"><a href="#2-字符串操作方法" class="headerlink" title="2. 字符串操作方法"></a>2. 字符串操作方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> concat()</li>
<li><p>用于将一或多个字符串拼接起来,返回拼接得到的新字符串.()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &apos;hello &apos;;</div><div class="line">var result = stringValue.concat(&apos;world&apos;);</div><div class="line">alert(result); // &apos;hello world&apos;</div><div class="line">alert(stringValue); // &apos;hello &apos;</div></pre></td></tr></table></figure>
</li>
<li><p>[x] slice()、substr()和 substring()</p>
</li>
<li><p>它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.substring(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.substr(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.slice(3, 7));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3,7));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substr(3, 7));//&quot;lo worl&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传 入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为 0。最后，substring()方法会把所有负值参数都转换为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(-3));//&quot;rld&quot;</div><div class="line">alert(stringValue.substring(-3));//&quot;hello world&quot;</div><div class="line">alert(stringValue.substr(-3));//&quot;rld&quot;</div><div class="line">alert(stringValue.slice(3, -4));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, -4));//&quot;hel&quot;</div><div class="line">alert(stringValue.substr(3, -4));//&quot;&quot;(空字符串)</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-字符串位置方法"><a href="#3-字符串位置方法" class="headerlink" title="3. 字符串位置方法"></a>3. 字符串位置方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> indexOf()和lastIndexOf()</li>
<li>从一个字符串中搜索给定的子字符串，然后返子字符串的位置(如果没有找到该子字符串，则返回-1)。这两个方法的区别在于:indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;));//4</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));//7</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;, 6));//7</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); //4</div></pre></td></tr></table></figure>
<h5 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4. trim()方法"></a>4. trim()方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;   hello world   &quot;;</div><div class="line">var trimmedStringValue = stringValue.trim();</div><div class="line">alert(stringValue);//&quot;   hello world   &quot;</div><div class="line">alert(trimmedStringValue);//&quot;hello world&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-字符串大小写转换方法"><a href="#5-字符串大小写转换方法" class="headerlink" title="5. 字符串大小写转换方法"></a>5. 字符串大小写转换方法</h5><p>ECMAScript 中涉及字符串大小写转换的方法有 4 个:toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()。其中，toLowerCase()和toUpperCase()是两个经典的方法,toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现.</p>
<h5 id="6-split"><a href="#6-split" class="headerlink" title="6. split()"></a>6. split()</h5><p>这个方法可以基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方 法不会将字符串看成正则表达式)。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red,blue,green,yellow&quot;;</div><div class="line">var colors1 =colorText.split(&quot;,&quot;); //[&apos;red&apos;,&apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos;]</div><div class="line">var colors2 = colorText.split(&quot;,&quot;, 2); //[&quot;red&quot;, &quot;blue&quot;]</div><div class="line">var colors3 = colorText.split(/[^\,]+/); //[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="1-5-7-单体内置对象"><a href="#1-5-7-单体内置对象" class="headerlink" title="1.5.7 单体内置对象"></a>1.5.7 单体内置对象</h3><p>ECMA-262 对内置对象的定义是:“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对 象在 ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object、Array 和 String。<br>ECMA-262还定义了两个单体内置对象:Global 和 Math。</p>
<h4 id="1-Global对象"><a href="#1-Global对象" class="headerlink" title="1. Global对象"></a>1. Global对象</h4><p>ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的.</p>
<p>isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global 对象还包含其他一些方法。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> URI 编码方法</li>
<li>encodeURI()和encodeURIComponent()方法可以对 URI(UniformResourceIdentifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对URI进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</li>
<li>encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对 URI 中的某一段进行编码。</li>
<li>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号;而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http://www.wrox.com/illegalvalue.htm#start&quot;;</div><div class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</div><div class="line">alert(encodeURI(uri));</div><div class="line"></div><div class="line">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</div><div class="line">alert(encodeURIComponent(uri));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 %20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以 对整个 URI 使用encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent() 的原因所在。</p>
<p><strong>一般来说，我们使用 encodeURIComponent()方法的时候要比使用 encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</strong></p>
<p>与 encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> eval()方法</li>
<li><p>eval() 方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript) 字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eval(&quot;alert(&apos;hi&apos;)&quot;);</div><div class="line">相当于</div><div class="line">alert(&quot;hi&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>[x] Global 对象的属性</p>
</li>
<li>特殊的值undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和Function，也都是Global 对象的属性。Global对象的所有属性:</li>
<li>undefined、NaN、Infinity、Object、Array、Function、Boolean、String、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</li>
<li style="list-style: none"><input type="checkbox" checked> window对象</li>
<li>ECMAScript虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window 对象的属性。<h4 id="2-Math对象"><a href="#2-Math对象" class="headerlink" title="2. Math对象"></a>2. Math对象</h4></li>
<li><p>[x] min()和 max()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var max = Math.max(3, 54, 32, 16);</div><div class="line">alert(max);    //54</div><div class="line">var min = Math.min(3, 54, 32, 16);</div><div class="line">alert(min);    //3</div></pre></td></tr></table></figure>
</li>
<li><p>在数组中找出最大值或最小值，使用apply()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5,6,7];</div><div class="line">var max = Math.max.apply(Math, arr);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个技巧的关键是把Math对象作为apply()的第一个参数，从而正确地设置 this 值。然后，可 以将任何数组作为第二个参数。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 舍入方法</li>
</ul>
<p>下面来介绍将小数值舍入为整数的几个方法:Math.ceil()、Math.floor()和Math.round()。这三个方法分别遵循下列舍入规则:</p>
<ul>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数;</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数;</li>
<li><p>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alert(Math.ceil(25.9));     //26</div><div class="line">alert(Math.ceil(25.5));     //26</div><div class="line">alert(Math.ceil(25.1));     //26</div><div class="line">alert(Math.round(25.9));    //26</div><div class="line">alert(Math.round(25.5));    //26</div><div class="line">alert(Math.round(25.1));    //25</div><div class="line">alert(Math.floor(25.9));    //25</div><div class="line">alert(Math.floor(25.5));    //25</div><div class="line">alert(Math.floor(25.1));    //25</div></pre></td></tr></table></figure>
</li>
<li><p>[x] random()方法</p>
</li>
</ul>
<p>Math.random()方法返回大于等于 0 小于 1 的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random() 从某个整数范围内随机选择一个值。</p>
<p><strong>==值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)==</strong></p>
<p>公式中用到了 Math.floor()方法，这是因为 Math.random()总返回一个小数值。而用这个小数 值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个 1 到 10 之间的数值，可以像下面这样编写代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = Math.floor(Math.random() * 10 + 1);</div></pre></td></tr></table></figure>
<p>总共有 10 个可能的值(1到10)，而第一个可能的值是1。而如果想要选择一个介于 2 到 10 之间的值，就应该将上面的代码改成这样:<br>var num = Math.floor(Math.random() * 9 + 2);</p>
<p>从 2 数到 10 要数9个数，因此可能值的总数就是 9，而第一个可能的值就是 2。多数情况下，其实 都可以通过一个函数来计算可能值的总数和第一个可能的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function selectFrom(lowerValue, upperValue) &#123;</div><div class="line">    var choices = upperValue - lowerValue + 1;</div><div class="line">    return Math.floor(Math.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line">var num = selectFrom(2, 10);</div><div class="line">alert(num); // 介于2和10之间(包括2和10)的一个数值</div></pre></td></tr></table></figure></p>
<p>从数组中随机 取出一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;]; </div><div class="line">var color = colors[selectFrom(0, colors.length-1)];</div><div class="line">alert(color);//可能是数组中包含的任何一个字符串</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 其他方法(略)</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象， 现简要总结如下:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 引用类型与传统面向对象程序设计中的类相似，但实现不同</li>
<li style="list-style: none"><input type="checkbox" checked> Object是一个基础类型，其他所有类型都从 Object继承了基本的行为;</li>
<li style="list-style: none"><input type="checkbox" checked> Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能;</li>
<li style="list-style: none"><input type="checkbox" checked> Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能;</li>
<li style="list-style: none"><input type="checkbox" checked> RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表 达式功能。</li>
</ul>
<p>函数实际上是Function类型的实例，因此函数也是对象;而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。</p>
<p>因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类 型分别是:Boolean、Number和String。以下是它们共同的特征:</p>
<ul>
<li>每个包装类型都映射到同名的基本类型;</li>
<li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作;</li>
<li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li>
</ul>
<p>在所有代码执行之前，作用域中就已经存在两个内置对象:Global 和 Math。在大多数 ECMAScript 实现中都不能直接访问 Global 对象;不过，Web 浏览器实现了承担该角色的 window 对象。全局变 量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算 任务。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20171019 js变量、作用域、内存" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/10/19/20171019 js变量、作用域、内存/" class="article-date">
      <time datetime="2017-10-19T11:46:32.000Z" itemprop="datePublished">2017-10-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/10/19/20171019 js变量、作用域、内存/">js 变量、作用域、内存</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 理解基本类型和引用类型的值</li>
<li style="list-style: none"><input type="checkbox" checked> 理解执行环境</li>
<li style="list-style: none"><input type="checkbox" checked> 理解垃圾收集<h2 id="1-1-基本类型和引用类型的值"><a href="#1-1-基本类型和引用类型的值" class="headerlink" title="1.1 基本类型和引用类型的值"></a>1.1 基本类型和引用类型的值</h2>基本类型值指的是 简单的数据段，而引用类型值指那些可能由多个值构成的对象。<h3 id="1-1-1-动态的属性"><a href="#1-1-1-动态的属性" class="headerlink" title="1.1.1 动态的属性"></a>1.1.1 动态的属性</h3>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。但是，我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误。<h3 id="1-1-2-复制变量值"><a href="#1-1-2-复制变量值" class="headerlink" title="1.1.2 复制变量值"></a>1.1.2 复制变量值</h3><strong>基本类型</strong>:如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。<br><strong>引用类型</strong>:当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。<h3 id="1-1-3-传递参数"><a href="#1-1-3-传递参数" class="headerlink" title="1.1.3 传递参数"></a>1.1.3 传递参数</h3>ECMAScript中所有函数的参数都是按值传递的。<strong>访问变量有按值和按引用两种方式，而参数只能按值传递。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function setName(obj) &#123; </div><div class="line">obj.name = &quot;Nicholas&quot;; </div><div class="line">obj = new Object(); </div><div class="line">obj.name = &quot;Greg&quot;;</div><div class="line">&#125;</div><div class="line">var person = new Object();</div><div class="line">setName(person);</div><div class="line">alert(person.name);    //&quot;Nicholas&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。<br><strong>可以把ECMAScript函数的参数想象成局部变量。</strong></p>
<h3 id="1-1-4-检测类型"><a href="#1-1-4-检测类型" class="headerlink" title="1.1.4 检测类型"></a>1.1.4 检测类型</h3><p>typeof操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。如果变量的值是一个对象或 null，则typeof操作符会像下面例子中所示的那样返回”object”。</p>
<p>虽然在检测<strong>基本数据类型</strong>时 typeof 是非常得力的助手，但在检测<strong>引用类型</strong>的值时，这个操作符的 用处不大。</p>
<p>想知对象的类型，ECMAScript提供了instanceof操作符。语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = variable instanceof constructor</div></pre></td></tr></table></figure></p>
<p>根据规定，所有引用类型的值都是 Object 的实例。因此，==<strong>在检测一个引用类型值和 Object构造函数时，instanceof操作符始终会返回true</strong>==。当然，如果 ==<strong>使用instanceof操作符检测基本类型的值，则该操作符始终会返回false</strong>==,因为基本类型不是对象。</p>
<p><strong>使用typeof操作符检测函数时，该操作符会返回”function”</strong></p>
<h2 id="1-2-执行环境及作用域"><a href="#1-2-执行环境及作用域" class="headerlink" title="1.2 执行环境及作用域"></a>1.2 执行环境及作用域</h2><p><strong>JavaScript 没有块级作用域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">var color = &quot;blue&quot;;</div><div class="line">&#125;</div><div class="line">alert(color);    // &quot;blue&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var i = 0; i &lt; 10; i++)&#123;</div><div class="line">doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i);      //10</div></pre></td></tr></table></figure>
<h3 id="1-2-1-声明变量"><a href="#1-2-1-声明变量" class="headerlink" title="1.2.1 声明变量"></a>1.2.1 声明变量</h3><p>使用 var 声明的变量会自动被添加到最接近的环境中。如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境。</p>
<p>在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做 法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就 可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。</p>
<h3 id="1-2-2-查询标识符"><a href="#1-2-2-查询标识符" class="headerlink" title="1.2.2 查询标识符"></a>1.2.2 查询标识符</h3><p>搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到 了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上 搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味 着该变量尚未声明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavaScript变量可以用来保存两种类型的值:<strong>基本类型值和引用类型值</strong>。基本类型的值源自以下5种基本数据类型:<strong>Undefined、Null、Boolean、Number、String和Symbol(ES6)</strong>。基本类型值和引用类型值具 有以下特点:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中;</li>
<li style="list-style: none"><input type="checkbox" checked> 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本;</li>
<li style="list-style: none"><input type="checkbox" checked> 引用类型的值是对象，保存在堆内存中;</li>
<li style="list-style: none"><input type="checkbox" checked> 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针;</li>
<li style="list-style: none"><input type="checkbox" checked> 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同<br>一个对象;</li>
<li style="list-style: none"><input type="checkbox" checked> 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。</li>
</ul>
<p>所有变量(包括基本类型和引用类型)都存在于一个执行环境(也称为作用域)当中，这个执 行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 执行环境有全局执行环境(也称为全局环境)和函数执行环境之分;</li>
<li style="list-style: none"><input type="checkbox" checked> 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链;</li>
<li style="list-style: none"><input type="checkbox" checked> 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含(父)环境，乃至全<br>局环境</li>
<li style="list-style: none"><input type="checkbox" checked> 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据;</li>
<li style="list-style: none"><input type="checkbox" checked> 变量的执行环境有助于确定应该何时释放内存。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20171014 js基本概念" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/10/14/20171014 js基本概念/" class="article-date">
      <time datetime="2017-10-14T04:17:51.000Z" itemprop="datePublished">2017-10-14</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/10/14/20171014 js基本概念/">javascript 基本概念</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 语法 </li>
<li style="list-style: none"><input type="checkbox" checked> 数据类型</li>
<li style="list-style: none"><input type="checkbox" checked> 流控制语句</li>
<li style="list-style: none"><input type="checkbox" checked> 函数<h2 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h2></li>
<li>区分大小写</li>
</ul>
<p>ECMAScript 中的一切(变量、函数名和操作符)都区分大小写，函数名不能使用 typeof，因为它 是一个关键字，但 typeOf 则完全可以是一个有效的函数名。</p>
<ul>
<li>标识符</li>
</ul>
<p>标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符的格式：</p>
<ol>
<li>第一个字符必须是一个字母、下划线(_)或一个美元符号($);</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
<li>按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的<br>首字母大写。</li>
</ol>
<p>==不能把关键字、保留字、true、false 和 null 用作标识符==</p>
<ul>
<li>注释</li>
</ul>
<p>ECMAScript的注释包括单行注释和块级注释。<br>单行注释以两个斜杠开头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 单行注释</div></pre></td></tr></table></figure>
<p>块级注释以一个斜杠和一个星号开头，以一个星号和一个斜杠结尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">* 这是一个多行 </div><div class="line">* (块级)注释 </div><div class="line">*/</div></pre></td></tr></table></figure>
<ul>
<li>严格模式</li>
</ul>
<p>ECMAScript 5 引入了严格模式(strict mode)的概念。严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div></pre></td></tr></table></figure>
<p>在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function doSomething()&#123;</div><div class="line">    &quot;use strict&quot;;</div><div class="line">    //函数体 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>语句</li>
</ul>
<p>ECMAScript 中的语句以一个分号结尾;如果省略分号，则由解析器确定语句的结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var sum = a + b // 即使没有分号也是有效的语句——不推荐</div><div class="line">var diff = a - b; // 有效的语句——推荐</div></pre></td></tr></table></figure>
<h2 id="1-2-关键字和保留字（了解）"><a href="#1-2-关键字和保留字（了解）" class="headerlink" title="1.2 关键字和保留字（了解）"></a>1.2 关键字和保留字（了解）</h2><p>ECMA描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或 者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。ECMAScript的关键字：</p>
<table>
<thead>
<tr>
<th>break</th>
<th>do</th>
<th>instanceof</th>
<th>typeof</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>else</td>
<td>new</td>
<td>var</td>
</tr>
<tr>
<td>catch</td>
<td>finally</td>
<td>return</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>debugger</td>
<td>function</td>
<td>this</td>
<td>with</td>
</tr>
<tr>
<td>default</td>
<td>if</td>
<td>throw</td>
<td>delete</td>
</tr>
<tr>
<td>in</td>
<td>try</td>
<td>abstract</td>
<td>enum</td>
</tr>
<tr>
<td>int</td>
<td>short</td>
<td>boolean</td>
<td>export</td>
</tr>
<tr>
<td>interface</td>
<td>static</td>
<td>byte</td>
<td>extends</td>
</tr>
<tr>
<td>long</td>
<td>super</td>
<td>char</td>
<td>final</td>
</tr>
<tr>
<td>native</td>
<td>synchronized</td>
<td>class</td>
<td>float</td>
</tr>
<tr>
<td>package</td>
<td>throws</td>
<td>const</td>
<td>goto</td>
</tr>
<tr>
<td>private</td>
<td>transient</td>
<td>debugger</td>
<td>implements</td>
</tr>
<tr>
<td>protected</td>
<td>volatile</td>
<td>double</td>
<td>import</td>
</tr>
<tr>
<td>public</td>
<td></td>
</tr>
</tbody>
</table>
<p>第 5 版把在非严格模式下运行时的保留字缩减为下列这些:</p>
<table>
<thead>
<tr>
<th>class</th>
<th>enum</th>
<th>extends</th>
<th>super</th>
</tr>
</thead>
<tbody>
<tr>
<td>const</td>
<td>export</td>
<td>import</td>
</tr>
</tbody>
</table>
<p>在严格模式下，第 5 版还对以下保留字施加了限制:</p>
<table>
<thead>
<tr>
<th>implements</th>
<th>package</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>interface</td>
<td>private</td>
<td>static</td>
</tr>
<tr>
<td>let</td>
<td>protected</td>
<td>yield</td>
</tr>
</tbody>
</table>
<h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。定义变量时要使用 var 操作符，后跟变量名。</p>
<ul>
<li>全局变量</li>
<li>局部变量<h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2>ECMAScript 中有 6 种简单数据类型(也称为基本数据类型):Undefined、Null、Boolean、Number 、String和Symbol(es6新增一种Symbol)。还有 1 种复杂数据类型——Object。<h3 id="1-4-1-typeof操作符"><a href="#1-4-1-typeof操作符" class="headerlink" title="1.4.1 typeof操作符"></a>1.4.1 typeof操作符</h3></li>
</ul>
<p>检测数据类型的一种方法。</p>
<blockquote>
<p>“undefined”——如果这个值未定义;<br>“boolean”——如果这个值是布尔值;<br>“string”——如果这个值是字符串;<br>“number”——如果这个值是数值;<br>“object”——如果这个值是对象或 null;<br>“function”——如果这个值是函数;<br>“symbol”–如果这个值是Symbol。</p>
</blockquote>
<p>有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回”object”，因为特殊值 null 被认为是一个空的对象引用。</p>
<h3 id="1-4-2-Undefined类型"><a href="#1-4-2-Undefined类型" class="headerlink" title="1.4.2 Undefined类型"></a>1.4.2 Undefined类型</h3><p>Undefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时,这个变量的值就是 undefined，对于尚未声明过的变量，只能执行一项操作，即使用 typeof 操作符检测其数据类型。</p>
<h3 id="1-4-3-Null类型"><a href="#1-4-3-Null类型" class="headerlink" title="1.4.3 Null类型"></a>1.4.3 Null类型</h3><p>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因，如下面 的例子所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var car = null;</div><div class="line">alert(typeof car); // &quot;object&quot;</div></pre></td></tr></table></figure>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子 所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (car != null)&#123;</div><div class="line">   // 对 car 对象执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上，undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(null == undefined); //true</div></pre></td></tr></table></figure>
<p><strong>如前所述，无论在什么情况下 都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说， 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</strong></p>
<h3 id="1-4-4-Boolean类型"><a href="#1-4-4-Boolean类型" class="headerlink" title="1.4.4 Boolean类型"></a>1.4.4 Boolean类型</h3><p>Boolean类型只有两个字面值:true 和 false。<br>要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()。<br>各种数据类型及其对 应的转换规则：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值(包括无穷大)</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td></td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h3 id="1-4-5-Number类型"><a href="#1-4-5-Number类型" class="headerlink" title="1.4.5 Number类型"></a>1.4.5 Number类型</h3><ol>
<li>浮点数值</li>
</ol>
<p>==0.1 + 0.2 != 0.3==</p>
<p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家;其他使用相同数值格式的语言也存在这个问题。</p>
<ol>
<li>数值范围</li>
</ol>
<p>由于内存的限制，ECMAScript 并不能保存世界上所有的数值。<br>ECMAScript 能够表示的最小数值是 5e-324;最大数值是1.7976931348623157e+308</p>
<p>Infinity/-Infinity</p>
<p>要想确定一个数值是不是有穷的<br>,可以使用 isFinite()函数。</p>
<ol>
<li>NaN</li>
</ol>
<p>NaN，即非数值(Not a Number)是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数<br>未返回数值的情况(这样就不会抛出错误了)。<br>在 ECMAScript 中，任何数值除以 0 会返回 NaN1，因此不会影响其他代码的执行。NaN 与任何值都不相等，包括 NaN 本身。<br>要想确定一个参数是不是NaN，<br>ECMAScript 定义了 isNaN()函数。</p>
<p><strong>isNaN()也适用于对象。在基于对象调用 isNaN() 函数时，会首先调用对象的 valueOf()方法，然后确定该方法返回的值是否可以转 换为数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。 而这个过程也是 ECMAScript 中内置函数和操作符的一般执行流程。</strong></p>
<ol>
<li>数值转换</li>
</ol>
<p>有3个函数可以把非数值转换为数值:Number()、parseInt()和 parseFloat()。</p>
<p>第一个函数， 即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。</p>
<blockquote>
<p>Number()函数的转换规则：</p>
</blockquote>
<p>(1). 如果是 Boolean 值，true 和 false 将分别被转换为 1 和 0。</p>
<p>(2). 如果是数字值，只是简单的传入和返回。</p>
<p>(3). 如果是 null 值，返回 0。</p>
<p>(4). 如果是 undefined，返回 NaN。</p>
<p>(5). 如果是字符串，遵循下列规则:</p>
<ul>
<li>如果字符串中只包含数字(包括前面带正号或负号的情况)，则将其转换为十进制数值，即”1” 会变成 1，”123”会变成 123，而”011”会变成 11(注意:前导的零被忽略了);</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值(同样，也会忽 略前导零);</li>
<li>如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值;</li>
<li>如果字符串是空的(不包含任何字符)，则将其转换为 0;</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li>
</ul>
<p>(6). 如果是对象，则调用对象的 valueOf()方法，然后依照前面的规则转换返回的值。如果转换<br>的结果是 NaN，则调用对象的 toString()方法，然后再次依照前面的规则转换返回的字符串值。</p>
<blockquote>
<p>parseInt()函数的转换规则：</p>
</blockquote>
<p><strong>parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN;也就是说，用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如 果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。</strong></p>
<p> parseInt()函数提供第二个参数:转换时使用的基数(即多少进制)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var num1 = parseInt(&quot;10&quot;, 2);   //2 (按二进制解析)</div><div class="line">var num2 = parseInt(&quot;10&quot;, 8);   //8 (按八进制解析)</div><div class="line">var num3 = parseInt(&quot;10&quot;, 10);  //10(按十进制解析)</div><div class="line">var num4 = parseInt(&quot;10&quot;, 16);  //16(按十六进制解析)</div></pre></td></tr></table></figure>
<blockquote>
<p>parseFloat()函数的转换规则：</p>
</blockquote>
<p><strong>parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。</strong></p>
<p>parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导 的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基 数的用法。</p>
<h3 id="1-4-6-String类型"><a href="#1-4-6-String类型" class="headerlink" title="1.4.6 String类型"></a>1.4.6 String类型</h3><p>字符串可以由双<br>引号(“)或单引号(‘)表示。</p>
<p>(1). 字符字面量(转移字符)</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\b</td>
<td>空格</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\</td>
<td>斜杠</td>
</tr>
<tr>
<td>\’</td>
<td>单引号(‘)，在用单引号表示的字符串中使用。例如:’He said, \’hey.\’’</td>
</tr>
<tr>
<td>\”</td>
<td>双引号(“)，在用双引号表示的字符串中使用。例如:”He said, \”hey.\””</td>
</tr>
<tr>
<td>\xnn</td>
<td>以十六进制代码nn表示的一个字符(其中n为0~F)。例如，\x41表示”A”</td>
</tr>
<tr>
<td>\unnnn</td>
<td>　以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如，\u03a3表示希腊字符Σ</td>
</tr>
</tbody>
</table>
<p>(２). 转化为字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">toString();</div><div class="line"></div><div class="line">String();</div></pre></td></tr></table></figure>
<blockquote>
<p>toString();</p>
</blockquote>
<p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法，这个方法唯一要做的就是返回相应值的字符串表现。</p>
<p>==数值、布尔值、对象和字符串值都有 toString()方法。但 null 和 undefined 值没有这个方法。==<br>多数情况下，调用 toString()方法不必传递参数。但是，在调用数值的 toString()方法时，可 以传递一个参数:输出数值的基数。toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式表示的字符串值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString());   // &quot;10&quot;</div><div class="line">alert(num.toString(2));  // &quot;1010&quot;</div><div class="line">alert(num.toString(8));  // &quot;12&quot;</div><div class="line">alert(num.toString(10)); // &quot;10&quot;</div><div class="line">alert(num.toString(16)); // &quot;a&quot;</div></pre></td></tr></table></figure>
<blockquote>
<p>String();</p>
</blockquote>
<p>在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。String()函数转换规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果值是 null，则返回”null”;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果值是 undefined，则返回”undefined”。</li>
</ul>
<h3 id="1-4-7-Object类型"><a href="#1-4-7-Object类型" class="headerlink" title="1.4.7 Object类型"></a>1.4.7 Object类型</h3><p><strong>ECMAScript中的对象其实就是一组数据和功能的集合。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div></pre></td></tr></table></figure></p>
<p>如果不给构造函数传递参数，则可以省略后面的那一对圆括号(不推荐)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object;  //有效，但不推荐省略圆括号</div></pre></td></tr></table></figure></p>
<p><strong>Object 的每个实例都具有下列属性和方法:</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 8 就是 Object()。</li>
<li style="list-style: none"><input type="checkbox" checked> hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定(例 如:o.hasOwnProperty(“name”))。</li>
<li style="list-style: none"><input type="checkbox" checked> isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。</li>
<li style="list-style: none"><input type="checkbox" checked> propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li style="list-style: none"><input type="checkbox" checked> toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li style="list-style: none"><input type="checkbox" checked> toString():返回对象的字符串表示。</li>
<li style="list-style: none"><input type="checkbox" checked> valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</li>
</ul>
<p>由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。</p>
<h2 id="1-5-操作符"><a href="#1-5-操作符" class="headerlink" title="1.5 操作符"></a>1.5 操作符</h2><p>ECMA 描述了一组用于操作数据值的操作符，包括<strong>算术操作符</strong>(如加号和减号)、<strong>位操作符</strong>、<strong>关系操作符</strong>和<strong>相等操作符</strong>。==在应用于对象时，相应的操作符通常都会调用对象的valueOf()和(或)toString()方法，以便取得可以操作的值==。</p>
<h3 id="1-5-1-一元操作符"><a href="#1-5-1-一元操作符" class="headerlink" title="1.5.1 一元操作符"></a>1.5.1 一元操作符</h3><p>只能操作一个值的操作符叫做一元操作符。</p>
<p>(1). 递增和递减操作符</p>
<p>前置递减/后置递减 or 前置递增/后置递增</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++1 、 1++  区别(先自加后运算、先运算后自加)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--1 、 1--   区别(先自加后运算、先运算后自减)</div></pre></td></tr></table></figure>
<p>(2). 一元加和减操作符(略)</p>
<h3 id="1-5-2-位操作符（略）"><a href="#1-5-2-位操作符（略）" class="headerlink" title="1.5.2 位操作符（略）"></a>1.5.2 位操作符（略）</h3><h3 id="1-5-3-布尔操作符"><a href="#1-5-3-布尔操作符" class="headerlink" title="1.5.3 布尔操作符"></a>1.5.3 布尔操作符</h3><p>==布尔操作符一共有 3 个:非!(NOT)、与&amp;&amp;(AND) 和或||(OR)。==</p>
<h4 id="1-逻辑非"><a href="#1-逻辑非" class="headerlink" title="1. 逻辑非"></a>1. 逻辑非</h4><p>逻辑非操作符由一个叹号(!)表示。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反，逻辑非操作符遵循下列规则：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是一个对象，返回 false;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是一个空字符串，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是一个非空字符串，返回 false;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是数值 0，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是任意非 0 数值(包括 Infinity)，返回 false;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是 null，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是 NaN，返回 true;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数是 undefined，返回 true。</li>
</ul>
<h4 id="2-逻辑与"><a href="#2-逻辑与" class="headerlink" title="2. 逻辑与"></a>2. 逻辑与</h4><p>逻辑与操作符由两个和号(&amp;&amp;)表示，有两个操作数。</p>
<p>两个操作数都是布尔值（略）。</p>
<p>有一个操作数不是布尔值遵循下列规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果第一个操作数是对象，则返回第二个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是对象，则返回第二个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 null，则返回 null;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则返回 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 undefined，则返回 undefined。</li>
</ul>
<p><strong>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。</strong></p>
<h4 id="3-逻辑或"><a href="#3-逻辑或" class="headerlink" title="3. 逻辑或"></a>3. 逻辑或</h4><p>逻辑或操作符由两个竖线符号(||)表示，有两个操作数，</p>
<p>两个操作数都是布尔值（略）。</p>
<p>有一个操作数不是布尔值遵循下列规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果第一个操作数是对象，则返回第一个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果第一个操作数的求值结果为 false，则返回第二个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是对象，则返回第一个操作数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是 null，则返回 null;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是 NaN，则返回 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是 undefined，则返回 undefined。</li>
</ul>
<p><strong>与逻辑与操作符相似，逻辑或操作符也是短路操作符。</strong></p>
<h3 id="1-5-4-乘性操作符"><a href="#1-5-4-乘性操作符" class="headerlink" title="1.5.4 乘性操作符"></a>1.5.4 乘性操作符</h3><p>3个乘性操作符:乘法、除法和求模</p>
<p>乘法、除法(省略)</p>
<p>求模：求模操作符会遵循下列特殊规则来处理特殊的值:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果操作数都是数值，执行常规的除法计算，返回除得的余数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是有限大的数值而除数是零，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 被 Infinity 除，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果被除数是零，则结果是零;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li>
</ul>
<h3 id="1-5-5-加性操作符"><a href="#1-5-5-加性操作符" class="headerlink" title="1.5.5 加性操作符"></a>1.5.5 加性操作符</h3><h4 id="1-加法"><a href="#1-加法" class="headerlink" title="1. 加法"></a>1. 加法</h4><p>如果==两个操作符都是数值==，执行常规的加法计算，然后根据下列规则返回结果:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 加 Infinity，则结果是 Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是-Infinity 加-Infinity，则结果是-Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 加-Infinity，则结果是 NaN;</li>
</ul>
<p>如果==有一个操作数是字符串==，那么就要应用如下规则:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接<br>起来。</li>
</ul>
<p>如果==有一个操作数是对象、数值或布尔值==，则调用它们的 toString()方法取得相应的字符串值，<br>然后再应用前面关于字符串的规则。对于 undefined 和 null，则分别调用 String()函数并取得字符 串”undefined”和”null”。</p>
<h4 id="2-减法"><a href="#2-减法" class="headerlink" title="2. 减法"></a>2. 减法</h4><p>减法操作符运算规则：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作符都是数值，则执行常规的算术减法操作并返回结果;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 减 Infinity，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是-Infinity 减-Infinity，则结果是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是 Infinity 减-Infinity，则结果是 Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果是-Infinity 减 Infinity，则结果是-Infinity;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是字符串、布尔值、null 或 undefined，则先在后台调用 Number()函数将<br>其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果<br>就是 NaN;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到<br>的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()<br>方法并将得到的字符串转换为数值。<h3 id="1-5-6-关系操作符"><a href="#1-5-6-关系操作符" class="headerlink" title="1.5.6 关系操作符"></a>1.5.6 关系操作符</h3>小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)，运算规则：</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是数值，则执行数值比较。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执<br>行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面<br>的规则执行比较。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li>
</ul>
<p>==常见的奇怪的现象：==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var result = &quot;Brick&quot; &lt; &quot;alphabet&quot;;    //true</div><div class="line"></div><div class="line">var result = &quot;23&quot; &lt; &quot;3&quot;;    //true</div><div class="line"></div><div class="line">var result = &quot;23&quot; &lt; 3;    //false</div><div class="line"></div><div class="line">var result = &quot;a&quot; &lt; 3; // false，因为&quot;a&quot;被转换成了 NaN</div><div class="line"></div><div class="line">var result1 = NaN &lt; 3; //false</div><div class="line"></div><div class="line">var result2 = NaN &gt;= 3; //false</div></pre></td></tr></table></figure></p>
<p>==<strong>根据规则，任何操作数与 NaN 进行关系比较，结果都是 false。</strong>==</p>
<h3 id="1-5-7-相等操作符"><a href="#1-5-7-相等操作符" class="headerlink" title="1.5.7 相等操作符"></a>1.5.7 相等操作符</h3><h4 id="1-相等和不相等"><a href="#1-相等和不相等" class="headerlink" title="1. 相等和不相等"></a>1. 相等和不相等</h4><p>运算规则：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而<br>true 转换为 1;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值;</li>
<li style="list-style: none"><input type="checkbox" checked> 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类<br>型值按照前面的规则进行比较;</li>
<li style="list-style: none"><input type="checkbox" checked> null 和 undefined 是相等的。</li>
<li style="list-style: none"><input type="checkbox" checked> 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示:<br>即使两个操作数都是 NaN，相等操作符也返回 false;因为按照规则，NaN 不等于 NaN。</li>
<li style="list-style: none"><input type="checkbox" checked> 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，<br>则相等操作符返回 true;否则，返回 false。<h4 id="2-全等和不全等-略"><a href="#2-全等和不全等-略" class="headerlink" title="2. 全等和不全等(略)"></a>2. 全等和不全等(略)</h4><h3 id="1-5-8-逗号操作符"><a href="#1-5-8-逗号操作符" class="headerlink" title="1.5.8 逗号操作符"></a>1.5.8 逗号操作符</h3>使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num1=1, num2=2, num3=3;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>逗号操作符多用于声明多个变量;但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号 操作符总会返回表达式中的最后一项，如下面的例子所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = (5, 1, 4, 8, 0); // num的值为0</div></pre></td></tr></table></figure></p>
<h2 id="1-6-语句"><a href="#1-6-语句" class="headerlink" title="1.6 语句"></a>1.6 语句</h2><h3 id="1-6-1-if语句-略"><a href="#1-6-1-if语句-略" class="headerlink" title="1.6.1 if语句(略)"></a>1.6.1 if语句(略)</h3><h3 id="1-6-2-do-while语句-略"><a href="#1-6-2-do-while语句-略" class="headerlink" title="1.6.2 do-while语句(略)"></a>1.6.2 do-while语句(略)</h3><p>do-while 语句是一种后测试循环语句，循环体内的代码至少会被执行一次</p>
<h3 id="1-6-3-while语句-略"><a href="#1-6-3-while语句-略" class="headerlink" title="1.6.3 while语句(略)"></a>1.6.3 while语句(略)</h3><h3 id="1-6-4-for语句-略"><a href="#1-6-4-for语句-略" class="headerlink" title="1.6.4 for语句(略)"></a>1.6.4 for语句(略)</h3><h3 id="1-6-5-for-in语句"><a href="#1-6-5-for-in语句" class="headerlink" title="1.6.5 for-in语句"></a>1.6.5 for-in语句</h3><p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。以下是 for-in 语句的语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for (property in expression) statement</div></pre></td></tr></table></figure></p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var propName in window) &#123;</div><div class="line">     document.write(propName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-6-6-break和continue语句"><a href="#1-6-6-break和continue语句" class="headerlink" title="1.6.6 break和continue语句"></a>1.6.6 break和continue语句</h3><p>==break 和 continue 语句用于在循环中精确地控制代码的执行。其中，break 语句会立即退出循环， 强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。==</p>
<h3 id="1-6-7-switch语句"><a href="#1-6-7-switch语句" class="headerlink" title="1.6.7 switch语句"></a>1.6.7 switch语句</h3><p>switch语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">switch (expression) &#123;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      case value: statement</div><div class="line">        break;</div><div class="line">      default: statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果合并多个case，添加注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">switch (i) &#123;</div><div class="line">    case 25:</div><div class="line">        /* 合并两种情形 */ </div><div class="line">    case 35:</div><div class="line">        alert(&quot;25 or 35&quot;);</div><div class="line">        break;</div><div class="line">    case 45:</div><div class="line">        alert(&quot;45&quot;);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        alert(&quot;Other&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h2><p>函数的基本语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function functionName(arg0, arg1,...,argN) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>严格模式对函数有一些限制:</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 不能把函数命名为 eval 或 arguments;</li>
<li style="list-style: none"><input type="checkbox" checked> 不能把参数命名为 eval 或 arguments;</li>
<li style="list-style: none"><input type="checkbox" checked> 不能出现两个命名参数同名的情况。<h3 id="1-7-1-理解函数参数"><a href="#1-7-1-理解函数参数" class="headerlink" title="1.7.1 理解函数参数"></a>1.7.1 理解函数参数</h3>ECMAScript 中的参数在内部是用一个类数组来表示的，<br>可以使用方括号语法访问它的每一个元素，例如arguments[0]，也可以用length属性来确定传递进来多少个参数<h3 id="1-7-2-没有重载"><a href="#1-7-2-没有重载" class="headerlink" title="1.7.2 没有重载"></a>1.7.2 没有重载</h3>ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言(如 Java)中，可以为一个函数 编写两个定义，只要这两个定义的签名(接受的参数的类型和数量)不同即可。如前所述，ECMAScirpt 函数没有签名，因为其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可 能做到的。<br><strong>通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载。</strong></li>
</ul>
<h2 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h2><p>ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。</p>
<p>以下简要总结了 ECMAScript 中基本的要素：</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript中的<strong>基本数据类型</strong>包括 Undefined、Null、Boolean、Number、String和Symbol(ES6新增)</li>
<li style="list-style: none"><input type="checkbox" checked> 与其他语言不同，ECMScript 没有为整数和浮点数值分别定义不同的数据类型，Number 类型可<br>用于表示所有数值。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript中也有一种<strong>复杂的数据类型</strong>，即 Object类型，该类型是这门语言中所有对象的基<br>础类型。</li>
<li style="list-style: none"><input type="checkbox" checked> 严格模式为这门语言中容易出错的地方施加了限制。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript 提供了很多与C及其他类 C语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript从其他语言中借鉴了很多流控制语句，例如if语句、for语句和switch语句等。ECMAScript中的函数与其他语言中的函数有诸多不同之处。</li>
<li style="list-style: none"><input type="checkbox" checked> 无须指定函数的返回值，因为任何 ECMAScript函数都可以在任何时候返回任何值。</li>
<li style="list-style: none"><input type="checkbox" checked> 实际上，未指定返回值的函数返回的是一个特殊的 undefined值。</li>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的</li>
<li style="list-style: none"><input type="checkbox" checked> 可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数</li>
<li style="list-style: none"><input type="checkbox" checked> 由于不存在函数签名的特性，ECMAScript 函数不能重载。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-20170921 js组成" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/09/17/20170921 js组成/" class="article-date">
      <time datetime="2017-09-17T12:56:29.000Z" itemprop="datePublished">2017-09-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017/09/17/20170921 js组成/">javascript 组成</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="js的组成"><a href="#js的组成" class="headerlink" title="js的组成"></a>js的组成</h1><ul>
<li><strong>核心(ECMAScript):++提供核心语言功能++</strong></li>
<li><strong>文档对象模型(DOM):++提供访问和操作网页内容的方法和接口++</strong></li>
<li><strong>浏览器对象模型(BOM):++提供与浏览器交互的方法和接口++</strong><h2 id="1-1-ECMAScript"><a href="#1-1-ECMAScript" class="headerlink" title="1.1 ECMAScript"></a>1.1 ECMAScript</h2>ECMAScript 与 Web 浏览器没有依赖关系，这门语言本身并不包含输入和输出定义。Web 浏览器只是 ECMAScript 实现可能的<strong>宿主环境</strong>之一。这门语言的组成部分:</li>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>操作符</li>
<li>对象<h2 id="1-2-文档对象模型-DOM"><a href="#1-2-文档对象模型-DOM" class="headerlink" title="1.2 文档对象模型(DOM)"></a>1.2 文档对象模型(DOM)</h2>文档对象模型(DOM，Document Object Model)是针对 XML 但经过扩展用于 HTML 的应用程序编 程接口(API，Application Programming Interface)。DOM 把整个页面映射为一个多层节点结构。HTML 7 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。<strong>DOM 并不只是针对 JavaScript 的</strong>，很多别的语言也都实现了 DOM。 不过，在 Web 浏览器中，基于 ECMAScript 实现的 DOM 的确已经成为 JavaScript 这 门语言的一个重要组成部分。DOM 级别：</li>
<li>DOM1</li>
<li>DOM2</li>
<li>DOM3<h2 id="1-3-浏览器对象模型-BOM"><a href="#1-3-浏览器对象模型-BOM" class="headerlink" title="1.3 浏览器对象模型(BOM)"></a>1.3 浏览器对象模型(BOM)</h2>浏览器对象模型(BOM，Browser Object Model)，从根本上讲，BOM 只处理浏览器窗口和框架;但人们习惯上也把所有针对浏览器的 JavaScript 扩展 算作 BOM 的一部分。下面就是一些这样的扩展:</li>
<li>弹出新浏览器窗口的功能;</li>
<li>移动、缩放和关闭浏览器窗口的功能;</li>
<li>提供浏览器详细信息的 navigator 对象;</li>
<li>提供浏览器所加载页面的详细信息的 location 对象;</li>
<li>提供用户显示器分辨率详细信息的 screen 对象;</li>
<li>对 cookies 的支持;</li>
<li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li>
</ul>
<p>由于没有 BOM 标准可以遵循，因此每个浏览器都有自己的实现。现在有了 HTML5，BOM 实现的细节有望朝着兼容性越来越高的方向发展。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 Lucien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/blog/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
             title: "a.article-title, .article-more-link a", 
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>