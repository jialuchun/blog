<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Lucien" />



<meta name="description" content="引用类型  使用对象  创建并操作数组  理解基本的JavaScript类型  使用基本类型和基本包装类型1.1 Object类型==创建Object实例的方式有两种==。 第一种是使用 new 操作符后跟 Object 构造函数 123var person = new Object();person.name = &amp;quot;Nicholas&amp;quot;;person.age = 29;  另一">
<meta property="og:type" content="article">
<meta property="og:title" content="js 引用类型">
<meta property="og:url" content="https://github.com/jialuchun/blog/2017/11/28/20171128 js引用类型/index.html">
<meta property="og:site_name" content="Blogs Of Lucien">
<meta property="og:description" content="引用类型  使用对象  创建并操作数组  理解基本的JavaScript类型  使用基本类型和基本包装类型1.1 Object类型==创建Object实例的方式有两种==。 第一种是使用 new 操作符后跟 Object 构造函数 123var person = new Object();person.name = &amp;quot;Nicholas&amp;quot;;person.age = 29;  另一">
<meta property="og:updated_time" content="2017-11-28T12:32:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js 引用类型">
<meta name="twitter:description" content="引用类型  使用对象  创建并操作数组  理解基本的JavaScript类型  使用基本类型和基本包装类型1.1 Object类型==创建Object实例的方式有两种==。 第一种是使用 new 操作符后跟 Object 构造函数 123var person = new Object();person.name = &amp;quot;Nicholas&amp;quot;;person.age = 29;  另一">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Blogs Of Lucien" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/blog/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>js 引用类型 | Blogs Of Lucien</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/blog/" class="profilepic">
            <img src="http://mamaj-oss-ws.oss-cn-beijing.aliyuncs.com/free/Jia/luchun/photo.jpeg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/blog/">Lucien</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/blog/archives/">主页</a></li>
                        
                            <li><a href="/blog/archives/">所有文章</a></li>
                        
                            <li><a href="/blog/tags/">标签云</a></li>
                        
                            <li><a href="/blog/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/blog/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Lucien</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/blog/" class="profilepic">
                <img src="http://mamaj-oss-ws.oss-cn-beijing.aliyuncs.com/free/Jia/luchun/photo.jpeg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/blog/" title="回到主页">Lucien</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/blog/archives/">主页</a></li>
                
                    <li><a href="/blog/archives/">所有文章</a></li>
                
                    <li><a href="/blog/tags/">标签云</a></li>
                
                    <li><a href="/blog/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:123@123.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/blog/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-20171128 js引用类型" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2017/11/28/20171128 js引用类型/" class="article-date">
      <time datetime="2017-11-28T12:31:49.000Z" itemprop="datePublished">2017-11-28</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      js 引用类型
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><ul>
<li style="list-style: none"><input type="checkbox" checked> 使用对象</li>
<li style="list-style: none"><input type="checkbox" checked> 创建并操作数组</li>
<li style="list-style: none"><input type="checkbox" checked> 理解基本的JavaScript类型</li>
<li style="list-style: none"><input type="checkbox" checked> 使用基本类型和基本包装类型<h2 id="1-1-Object类型"><a href="#1-1-Object类型" class="headerlink" title="1.1 Object类型"></a>1.1 Object类型</h2>==创建Object实例的方式有两种==。</li>
<li><p>第一种是使用 new 操作符后跟 Object 构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Nicholas&quot;;</div><div class="line">person.age = 29;</div></pre></td></tr></table></figure>
</li>
<li><p>另一种方式是使用对象字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name : &quot;Nicholas&quot;,</div><div class="line">    age : 29</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-2-Array类型"><a href="#1-2-Array类型" class="headerlink" title="1.2 Array类型"></a>1.2 Array类型</h2><p>==创建数组的基本方式有两种==。</p>
<ul>
<li><p>第一种是使用Array构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = new Array();</div><div class="line">var colors = new Array(20);</div><div class="line">var colors = new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">var colors = Array(3); // 创建一个包含 3 项的数组</div><div class="line">var names = Array(&quot;Greg&quot;); // 创建一个包含 1 项，即字符串&quot;Greg&quot;的数组</div></pre></td></tr></table></figure>
</li>
<li><p>使用数组字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; // 创建一个包含 3 个字符串的数组</div><div class="line">var names = []; // 创建一个空数组</div><div class="line">var values = [1,2,]; // 不要这样!这样会创建一个包含 2 或 3 项的数组</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-1-检测数组"><a href="#1-2-1-检测数组" class="headerlink" title="1.2.1 检测数组"></a>1.2.1 检测数组</h3><ul>
<li>instanceof 操作符<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (value instanceof Array)&#123;    </div><div class="line">    //对数组执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实 际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自 不同的构造函数。</p>
<ul>
<li>Array.isArray()<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (Array.isArray(value))&#123; </div><div class="line">    //对数组执行某些操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<h3 id="1-2-2-转换方法"><a href="#1-2-2-转换方法" class="headerlink" title="1.2.2 转换方法"></a>1.2.2 转换方法</h3><p>所有对象都具有toLocaleString()、toString()和 valueOf()方法。</p>
<ul>
<li>调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。</li>
<li>valueOf()返回的还是数组</li>
</ul>
<p>数组继承的toLocaleString()、toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 join()方法，则可以使用不同的分隔符来构建这个字符串。</p>
<h3 id="1-2-3-栈方法"><a href="#1-2-3-栈方法" class="headerlink" title="1.2.3 栈方法"></a>1.2.3 栈方法</h3><p>栈是一种LIFO(Last-In-First-Out，后进先出)的数据结构，也就是最新添加的项最早被移除。</p>
<p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。</p>
<ul>
<li>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并==返回修改后数组的长度==。</li>
<li>pop()方法则从数组末尾移除最后一项，减少数组的 length值，然后==返回移除的项==。<h3 id="1-2-4-队列方法"><a href="#1-2-4-队列方法" class="headerlink" title="1.2.4 队列方法"></a>1.2.4 队列方法</h3>队列数据结构的访问规则是FIFO(First-In-First-Out， 先进先出)。</li>
</ul>
<p>结合使用 shift()和push()方法，可以像使 用队列一样使用数组。</p>
<p>同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p>
<h3 id="1-2-5-重排序方法"><a href="#1-2-5-重排序方法" class="headerlink" title="1.2.5 重排序方法"></a>1.2.5 重排序方法</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> reverse()</li>
<li>reverse()方法会反转数组项的顺序</li>
<li style="list-style: none"><input type="checkbox" checked> sort()</li>
<li>sort()方法按升序排列数组项。</li>
<li>sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。这种排序方式在很多情况下都不是最佳方案。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0, 1, 5, 10, 15];</div><div class="line">values.sort();</div><div class="line">alert(values);     //0,1,10,15,5</div></pre></td></tr></table></figure>
</li>
</ul>
<p>==解决排序方案：==<br>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。</p>
<p>该比较函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数a和b，其返回值如下：</p>
<ul>
<li>若a小于b，在排序后的数组中a应该出现在 b 之前，则返回一个小于0的值。</li>
<li>若a等于b，则返回 0。</li>
<li>若a大于b，则返回一个大于0的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">    if (value1 &lt; value2) &#123;</div><div class="line">        return -1;</div><div class="line">    &#125; else if (value1 &gt; value2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个比较函数可以适用于大多数数据类型，只要将其作为参数传递给 sort()方法即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0, 1, 5, 10, 15];</div><div class="line">values.sort(compare);</div><div class="line">alert(values); //0,1,5,10,15</div></pre></td></tr></table></figure></p>
<p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2)&#123;</div><div class="line">    return value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="1-2-6-操作方法"><a href="#1-2-6-操作方法" class="headerlink" title="1.2.6 操作方法"></a>1.2.6 操作方法</h3><ul>
<li style="list-style: none"><input type="checkbox" checked> concat()</li>
<li>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数 添加到这个副本的末尾，最后返回新构建的数组。</li>
<li style="list-style: none"><input type="checkbox" checked> slice()</li>
<li>它能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项— —==<strong>但不包括结束位置的项</strong>==。注意，==slice()方法不会影响原始数组==。</li>
<li><p>如果结束位置小于起始位置，则返回空数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];</div><div class="line">var colors2 = colors.slice(1);</div><div class="line">var colors3 = colors.slice(1,4);</div><div class="line">alert(colors2);   //green,blue,yellow,purple</div><div class="line">alert(colors3);   //green,blue,yellow</div></pre></td></tr></table></figure>
</li>
<li><p>[x] splice()</p>
</li>
<li>splice()的主要用途是向数组的中部插入项：删除、插入、替换</li>
<li><strong>删除</strong>:可以删除任意数量的项，只需指定2个参数:要删除的第一项的位置和要删除的项数。 例如，splice(0,2)会删除数组中的前两项。</li>
<li><strong>插入</strong>:可以向指定位置插入任意数量的项，只需提供 3个参数:起始位置、0(要删除的项数)和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置 2 开始插入字符串”red”和”green”。</li>
<li><strong>替换</strong>:可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数:起 始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如， splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 “red”和”green”。</li>
<li>==splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项(如果没有删除任何 项，则返回一个空数组)。==</li>
<li>示例代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</div><div class="line">var removed = colors.splice(0,1);   // 删除第一项</div><div class="line">alert(colors); // green,blue </div><div class="line">alert(removed);//red，返回的数组中只包含一项</div><div class="line"></div><div class="line"></div><div class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;); // 从位置 1 开始插入两项</div><div class="line">alert(colors); // green,yellow,orange,blue</div><div class="line">alert(removed); // 返回的是一个空数组</div><div class="line"></div><div class="line"></div><div class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两项，删除一项</div><div class="line">alert(colors);  //green,red,purple,orange,blue</div><div class="line">alert(removed); //yellow，返回的数组中只包含一项</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-7-位置方法"><a href="#1-2-7-位置方法" class="headerlink" title="1.2.7 位置方法"></a>1.2.7 位置方法</h3><p>indexOf()和 lastIndexOf()。这两个方法都接收两个参数:要查找的项和(可选的)表示查找起点位置的索引。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1</p>
<p>在比较第一个参数与数组中的每一项时，会使用全等操作符。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> indexOf()</li>
<li>indexOf()方法从数组的开头(位置0)开始向后查找</li>
<li style="list-style: none"><input type="checkbox" checked> lastIndexOf()</li>
<li>lastIndexOf()方法可返回一个指定的字符串值==最后出现的位置==，在一个字符串中的指定位置从后向前搜索。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">alert(numbers.indexOf(4));  //3</div><div class="line">alert(numbers.lastIndexOf(4)); //5</div><div class="line">alert(numbers.indexOf(4, 4));     //5</div><div class="line">alert(numbers.lastIndexOf(4, 4)); //3</div><div class="line"></div><div class="line">var person = &#123; name: &quot;Nicholas&quot; &#125;;</div><div class="line">var people = [&#123; name: &quot;Nicholas&quot; &#125;];</div><div class="line">var morePeople = [person];</div><div class="line">alert(people.indexOf(person));     //-1</div><div class="line">alert(morePeople.indexOf(person)); //0</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-2-8-迭代方法"><a href="#1-2-8-迭代方法" class="headerlink" title="1.2.8 迭代方法"></a>1.2.8 迭代方法</h3><p><strong>以下方法都不会修改数组中的包含的值。</strong></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> every()</li>
<li>every():对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true</li>
<li style="list-style: none"><input type="checkbox" checked> some()</li>
<li>some():对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</li>
<li style="list-style: none"><input type="checkbox" checked> filter()</li>
<li>filter():对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li style="list-style: none"><input type="checkbox" checked> forEach()</li>
<li>forEach():对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li style="list-style: none"><input type="checkbox" checked> map()</li>
<li>map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
</ul>
<p>==every()、some()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.every(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">alert(everyResult); //false</div><div class="line"></div><div class="line">var someResult = numbers.some(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">alert(someResult); //true</div></pre></td></tr></table></figure></p>
<p>==filter()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var filterResult = numbers.filter(function(item, index, array)&#123;</div><div class="line">    return (item &gt; 2);</div><div class="line">&#125;);</div><div class="line">alert(filterResult);    //[3,4,5,4,3]</div></pre></td></tr></table></figure></p>
<p>==map()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var mapResult = numbers.map(function(item, index, array)&#123;</div><div class="line">    return item * 2;</div><div class="line">&#125;);</div><div class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</div></pre></td></tr></table></figure></p>
<p>==forEach()==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">numbers.forEach(function(item, index, array)&#123;</div><div class="line">    //执行某些操作</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="1-2-9归并方法"><a href="#1-2-9归并方法" class="headerlink" title="1.2.9归并方法"></a>1.2.9归并方法</h3><p>这两个方法都接收两个参数:一个在每一项上调用的函数和(可选的)作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收4 个参数:前一个值、当前值、项的索引和数组对象。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> reduce()</li>
<li>reduce()方法从数组的第一项开始，逐个遍历到最后</li>
<li style="list-style: none"><input type="checkbox" checked> reduceRight()</li>
<li>reduceRight()则从数组的最后一项开始，向前遍历到第一项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var values = [1,2,3,4,5];</div><div class="line">var sum = values.reduce(function(prev, cur, index, array)&#123;</div><div class="line">    return prev + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum); //15</div></pre></td></tr></table></figure>
</li>
</ul>
<p>第一次执行回调函数，prev 是 1，cur 是 2。第二次，prev 是 3(1 加 2 的结果)，cur 是 3(数组 的第三项)。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。<br>reduceRight()的作用类似，只不过方向相反而已。</p>
<h2 id="1-3-Date类型"><a href="#1-3-Date类型" class="headerlink" title="1.3 Date类型"></a>1.3 Date类型</h2><p>常用的日期方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Date(); // 返回当日的日期和时间。</div><div class="line">Data.now();//返回表示调用这个方法时的日期和时间的毫秒数</div><div class="line">var myDate=new Date();  //创建日期对象</div><div class="line">getTime();//返回 1970 年 1 月 1 日至今的毫秒数。</div><div class="line">getFullYear();//从 Date 对象以四位数字返回年份。</div><div class="line">getMonth();//从 Date 对象返回月份 (0 ~ 11)。</div><div class="line">getDate();//从 Date 对象返回一个月中的某一天 (1 ~ 31)。</div><div class="line">getDay();//从 Date 对象返回一周中的某一天 (0 ~ 6)。</div><div class="line">getHours();//返回 Date 对象的小时 (0 ~ 23)。</div><div class="line">getMinutes();//返回 Date 对象的分钟 (0 ~ 59)。</div><div class="line">getSeconds();//返回 Date 对象的秒数 (0 ~ 59)。</div></pre></td></tr></table></figure></p>
<h2 id="1-4-RegExp类型"><a href="#1-4-RegExp类型" class="headerlink" title="1.4 RegExp类型"></a>1.4 RegExp类型</h2><ul>
<li style="list-style: none"><input type="checkbox" checked> 字面量形式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var expression = / pattern / flags ; //语法</div></pre></td></tr></table></figure>
</li>
</ul>
<p>模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。</p>
<p>每个正则表达式都可带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志。</p>
<ul>
<li>g:表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止;</li>
<li>i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写;</li>
<li>m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*匹配字符串中所有&quot;at&quot;的实例</div><div class="line">*/</div><div class="line">var pattern1 = /at/g; </div><div class="line"></div><div class="line">/*</div><div class="line">*匹配第一个&quot;bat&quot;或“cat”，不区分大小写</div><div class="line">*/</div><div class="line">var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">/* 10 </div><div class="line">* 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写</div><div class="line">*/</div><div class="line">var pattern3 = /.at/gi;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与其他语言中的正则表达式类似，<strong>模式中使用的所有元字符都必须转义</strong>。正则表达式中的元字符包括:==( [ { \ ^ $ | ) ? * + .]}==</p>
<p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">*匹配第一个“bat”或“cat”，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern1 = /[bc]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配第一个&quot; [bc]at&quot;，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern2 = /\[bc\]at/i;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern3 = /.at/gi;</div><div class="line"></div><div class="line">/*</div><div class="line">* 匹配所有&quot;.at&quot;，不区分大小写 </div><div class="line">*/</div><div class="line">var pattern4 = /\.at/gi;</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> RegExp构造函数形式</li>
</ul>
<p>它接收两个参数:一个是要匹配的字符串模式，另一个是可选的标志字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var pattern2 = new RegExp(&quot;[bc]at&quot;, &quot;i&quot;);</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> RegExp实例方法</li>
<li>exec()</li>
<li>test()<h2 id="1-5-Function类型"><a href="#1-5-Function类型" class="headerlink" title="1.5 Function类型"></a>1.5 Function类型</h2><strong>每个函数都是 Function 类型的实例</strong>，而且都与其他引用类型一样具有属性和方法。<h3 id="1-5-1-函数声明与函数表达式"><a href="#1-5-1-函数声明与函数表达式" class="headerlink" title="1.5.1 函数声明与函数表达式"></a>1.5.1 函数声明与函数表达式</h3>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问);至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。<h3 id="1-5-2-作为值的函数"><a href="#1-5-2-作为值的函数" class="headerlink" title="1.5.2 作为值的函数"></a>1.5.2 作为值的函数</h3>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function callSomeFunction(someFunction,someArgument)&#123;</div><div class="line">    return someFunction(someArgument);</div><div class="line">&#125;</div><div class="line">function add10(num)&#123;</div><div class="line">    return num + 10;</div><div class="line">&#125;</div><div class="line">var result1 = callSomeFunction(add10, 10);</div><div class="line">alert(result1);   //20</div><div class="line"></div><div class="line">function getGreeting(name)&#123;</div><div class="line">    return &quot;Hello, &quot; + name;</div><div class="line">&#125;</div><div class="line">var result2 = callSomeFunction(getGreeting,&quot;Nicholas&quot;);</div><div class="line">alert(result2);   //&quot;Hello, Nicholas&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>callSomeFunction()函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。</p>
<h3 id="1-5-3-函数内部属性"><a href="#1-5-3-函数内部属性" class="headerlink" title="1.5.3 函数内部属性"></a>1.5.3 函数内部属性</h3><p>在函数内部，有两个特殊的对象:arguments 和 this。<br>虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if (num &lt;=1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * factorial(num-1)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义阶乘函数一般都要用到递归算法;如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if (num &lt;=1) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return num * arguments.callee(num-1)</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个重写后的factorial()函数的函数体内，没有再引用函数名 factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var trueFactorial = factorial;</div><div class="line">factorial = function()&#123;</div><div class="line">    return 0;</div><div class="line">&#125;;</div><div class="line">alert(trueFactorial(5));     //120</div><div class="line">alert(factorial(5));         //0</div></pre></td></tr></table></figure></p>
<p>在此，变量 trueFactorial获得了factorial的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回0的函数赋值给factorial变量。如果像原来的 factorial() 那样不使用arguments.callee，调用 trueFactorial()就会返回0。可是，在解除了函数体内的代 码与函数名的耦合状态之后，trueFactorial()仍然能够正常地计算阶乘;至于factorial()，它现在只是一个返回 0 的函数。</p>
<p>this 引用的是函数据以执行的环境对象——或者也可以说是 this 值(当在网页的全局作用域中调用函数时， this 对象引用的就是 window)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor();     //&quot;red&quot;</div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor();   //&quot;blue&quot;</div></pre></td></tr></table></figure></p>
<h3 id="1-5-4-函数属性和方法"><a href="#1-5-4-函数属性和方法" class="headerlink" title="1.5.4 函数属性和方法"></a>1.5.4 函数属性和方法</h3><p>每个函数都包含两个属性:length和prototype。其中，length 属性表示函数希望接收的命名参数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum.length);   //2</div></pre></td></tr></table></figure></p>
<p>prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString()和 valueOf()等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访 问罢了。在创建自定义引用类型以及实现继承时，prototype 属性的作用是极为重要的。在ECMAScript5中，prototype 属性是不可枚举的，因此使用 for-in 无法发现。</p>
<p>每个函数都包含两个非继承而来的方法:apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</p>
<p><strong>call()方法与apply()方法的作用相同，它们的区别仅在于</strong>接收参数的方式不同。对于call()方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">function callSum(num1, num2)&#123;</div><div class="line">    return sum.call(this, num1, num2);</div><div class="line">&#125;</div><div class="line">alert(callSum(10,10));   //20</div></pre></td></tr></table></figure></p>
<p>在使用 call()方法的情况下，callSum()必须明确地传入每一个参数。结果与使用apply()没有什么不同。至于是使用 apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。 如果你打算直接传入 arguments 对象，或者包含函数中先接收到的也是一个数组，那么使用 apply() 肯定更方便;否则，选择 call()可能更合适。</p>
<p>传递参数并非 apply()和call()真正的用武之地;<strong>它们真正强大的地方是能够扩充函数赖以运行的作用域。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">sayColor(); //red</div><div class="line">sayColor.call(this); //red</div><div class="line">sayColor.call(window); //red</div><div class="line">sayColor.call(o); //blue</div></pre></td></tr></table></figure></p>
<p>ECMAScript 5 还定义了一个方法:bind()。这个方法会创建一个函数的实例，其 this 值会被绑 定到传给 bind()函数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123; color: &quot;blue&quot; &#125;;</div><div class="line">function sayColor()&#123;</div><div class="line">    alert(this.color);</div><div class="line">&#125;</div><div class="line">var objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor();    //blue</div></pre></td></tr></table></figure></p>
<h3 id="1-5-6-基本包装类型"><a href="#1-5-6-基本包装类型" class="headerlink" title="1.5.6 基本包装类型"></a>1.5.6 基本包装类型</h3><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型:Boolean、Number 和 String。</p>
<p>==每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们 能够调用一些方法来操作这些数据。==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s2; // &quot;me text&quot;</div></pre></td></tr></table></figure></p>
<p>基本类型值不是对象，因而从逻辑上讲它们不应该有方法。其实，为了让我们实现这种直观的操作， 后台已经自动完成了一系列的处理。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 创建 String 类型的一个实例;</li>
<li style="list-style: none"><input type="checkbox" checked> 在实例上调用指定的方法;</li>
<li style="list-style: none"><input type="checkbox" checked> 销毁这个实例。</li>
</ul>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = new String(&quot;some text&quot;);</div><div class="line">var s2 = s1.substring(2);</div><div class="line">s1 = null;</div></pre></td></tr></table></figure></p>
<p><strong>引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法</strong>。来看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1 = &quot;some text&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">alert(s1.color);   //undefined</div></pre></td></tr></table></figure></p>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>Boolean 类型的实例重写了valueOf()方法，返回基本类型值 true 或 false;重写了 toString() 方法，返回字符串”true”和”false”。可是，Boolean 对象在 ECMAScript 中的用处不大，因为它经 常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var falseObject = new Boolean(false);</div><div class="line">var result = falseObject &amp;&amp; true;</div><div class="line">alert(result);  //true</div><div class="line"></div><div class="line">var falseValue = false;</div><div class="line">result = falseValue &amp;&amp; true;</div><div class="line">alert(result);  //false</div></pre></td></tr></table></figure></p>
<p>基本类型与引用类型的布尔值还有两个区别。首先，typeof 操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是 Boolean 类型的实例，所以使用instanceof操作符测试 Boolean对象会返回true，而测试基本类型的布尔值则返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(typeoffalseObject); //object</div><div class="line">alert(typeof falseValue); //boolean</div><div class="line">alert(falseObject instanceof Boolean);//true</div><div class="line">alert(falseValue instanceof Boolean);//false</div></pre></td></tr></table></figure></p>
<p><strong>建议是永远不要使 用 Boolean 对象。</strong></p>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>Number 类型也重写了valueOf()、toLocaleString()和 toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。</p>
<p>可以为 toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toString()); //&quot;10&quot;</div><div class="line">alert(num.toString(2)); //&quot;1010&quot;</div><div class="line">alert(num.toString(8)); //&quot;12&quot;</div><div class="line">alert(num.toString(10)); //&quot;10&quot;</div><div class="line">alert(num.toString(16)); //&quot;a&quot;</div></pre></td></tr></table></figure></p>
<p>除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中，toFixed()方法会按照指定的小数位返回数值的字符串表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var num = 10;</div><div class="line">alert(num.toFixed(2));  //&quot;10.00&quot;</div></pre></td></tr></table></figure></p>
<p>我们仍 然不建议直接实例化Number类型，而原因与显式创建Boolean对象一样。具体来讲，就是在使用 typeof 和instanceof操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。</p>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 valueOf()、toLocale- String()和 toString()方法，都返回对象所表示的基本字符串值。</p>
<p>String 类型的每个实例都有一个length属性，表示字符串中包含多个字符。</p>
<p>String 类型提供了很多方法，用于辅助完成对 ECMAScript中字符串的解析和操作.</p>
<h5 id="1-字符方法"><a href="#1-字符方法" class="headerlink" title="1. 字符方法"></a>1. 字符方法</h5><p>两个用于访问字符串中特定字符的方法是:charAt()和 charCodeAt()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charAt(1));   //&quot;e&quot;</div><div class="line"></div><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.charCodeAt(1));//输出&quot;101&quot;</div></pre></td></tr></table></figure></p>
<h5 id="2-字符串操作方法"><a href="#2-字符串操作方法" class="headerlink" title="2. 字符串操作方法"></a>2. 字符串操作方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> concat()</li>
<li><p>用于将一或多个字符串拼接起来,返回拼接得到的新字符串.()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &apos;hello &apos;;</div><div class="line">var result = stringValue.concat(&apos;world&apos;);</div><div class="line">alert(result); // &apos;hello world&apos;</div><div class="line">alert(stringValue); // &apos;hello &apos;</div></pre></td></tr></table></figure>
</li>
<li><p>[x] slice()、substr()和 substring()</p>
</li>
<li><p>它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.substring(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.substr(3));//&quot;lo world&quot;</div><div class="line">alert(stringValue.slice(3, 7));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3,7));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substr(3, 7));//&quot;lo worl&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传 入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个 参数转换为 0。最后，substring()方法会把所有负值参数都转换为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.slice(-3));//&quot;rld&quot;</div><div class="line">alert(stringValue.substring(-3));//&quot;hello world&quot;</div><div class="line">alert(stringValue.substr(-3));//&quot;rld&quot;</div><div class="line">alert(stringValue.slice(3, -4));//&quot;lo w&quot;</div><div class="line">alert(stringValue.substring(3, -4));//&quot;hel&quot;</div><div class="line">alert(stringValue.substr(3, -4));//&quot;&quot;(空字符串)</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-字符串位置方法"><a href="#3-字符串位置方法" class="headerlink" title="3. 字符串位置方法"></a>3. 字符串位置方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> indexOf()和lastIndexOf()</li>
<li>从一个字符串中搜索给定的子字符串，然后返子字符串的位置(如果没有找到该子字符串，则返回-1)。这两个方法的区别在于:indexOf()方法从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从字符串的末尾向前搜索子字符串.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;));//4</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;));//7</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">alert(stringValue.indexOf(&quot;o&quot;, 6));//7</div><div class="line">alert(stringValue.lastIndexOf(&quot;o&quot;, 6)); //4</div></pre></td></tr></table></figure>
<h5 id="4-trim-方法"><a href="#4-trim-方法" class="headerlink" title="4. trim()方法"></a>4. trim()方法</h5><ul>
<li style="list-style: none"><input type="checkbox" checked> ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及 后缀的所有空格，然后返回结果.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var stringValue = &quot;   hello world   &quot;;</div><div class="line">var trimmedStringValue = stringValue.trim();</div><div class="line">alert(stringValue);//&quot;   hello world   &quot;</div><div class="line">alert(trimmedStringValue);//&quot;hello world&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-字符串大小写转换方法"><a href="#5-字符串大小写转换方法" class="headerlink" title="5. 字符串大小写转换方法"></a>5. 字符串大小写转换方法</h5><p>ECMAScript 中涉及字符串大小写转换的方法有 4 个:toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()。其中，toLowerCase()和toUpperCase()是两个经典的方法,toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现.</p>
<h5 id="6-split"><a href="#6-split" class="headerlink" title="6. split()"></a>6. split()</h5><p>这个方法可以基于指定的分隔符将一个字符串分割成 多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象(这个方 法不会将字符串看成正则表达式)。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red,blue,green,yellow&quot;;</div><div class="line">var colors1 =colorText.split(&quot;,&quot;); //[&apos;red&apos;,&apos;blue&apos;, &apos;green&apos;, &apos;yellow&apos;]</div><div class="line">var colors2 = colorText.split(&quot;,&quot;, 2); //[&quot;red&quot;, &quot;blue&quot;]</div><div class="line">var colors3 = colorText.split(/[^\,]+/); //[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="1-5-7-单体内置对象"><a href="#1-5-7-单体内置对象" class="headerlink" title="1.5.7 单体内置对象"></a>1.5.7 单体内置对象</h3><p>ECMA-262 对内置对象的定义是:“由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对 象在 ECMAScript程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如 Object、Array 和 String。<br>ECMA-262还定义了两个单体内置对象:Global 和 Math。</p>
<h4 id="1-Global对象"><a href="#1-Global对象" class="headerlink" title="1. Global对象"></a>1. Global对象</h4><p>ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的.</p>
<p>isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global对象的方法。除此之外，Global 对象还包含其他一些方法。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> URI 编码方法</li>
<li>encodeURI()和encodeURIComponent()方法可以对 URI(UniformResourceIdentifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个 URI 编码方法就可以对URI进行编码，它们用特殊的 UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。</li>
<li>encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对 URI 中的某一段进行编码。</li>
<li>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号;而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http://www.wrox.com/illegalvalue.htm#start&quot;;</div><div class="line">// &quot;http://www.wrox.com/illegal%20value.htm#start&quot;</div><div class="line">alert(encodeURI(uri));</div><div class="line"></div><div class="line">// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</div><div class="line">alert(encodeURIComponent(uri));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用 encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 %20。而 encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以 对整个 URI 使用encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent() 的原因所在。</p>
<p><strong>一般来说，我们使用 encodeURIComponent()方法的时候要比使用 encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。</strong></p>
<p>与 encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> eval()方法</li>
<li><p>eval() 方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript) 字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eval(&quot;alert(&apos;hi&apos;)&quot;);</div><div class="line">相当于</div><div class="line">alert(&quot;hi&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>[x] Global 对象的属性</p>
</li>
<li>特殊的值undefined、NaN 以及 Infinity 都是 Global 对象的属性。此外，所有原生引用类型的构造函数，像 Object 和Function，也都是Global 对象的属性。Global对象的所有属性:</li>
<li>undefined、NaN、Infinity、Object、Array、Function、Boolean、String、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</li>
<li style="list-style: none"><input type="checkbox" checked> window对象</li>
<li>ECMAScript虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为 window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window 对象的属性。<h4 id="2-Math对象"><a href="#2-Math对象" class="headerlink" title="2. Math对象"></a>2. Math对象</h4></li>
<li><p>[x] min()和 max()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var max = Math.max(3, 54, 32, 16);</div><div class="line">alert(max);    //54</div><div class="line">var min = Math.min(3, 54, 32, 16);</div><div class="line">alert(min);    //3</div></pre></td></tr></table></figure>
</li>
<li><p>在数组中找出最大值或最小值，使用apply()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3,4,5,6,7];</div><div class="line">var max = Math.max.apply(Math, arr);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个技巧的关键是把Math对象作为apply()的第一个参数，从而正确地设置 this 值。然后，可 以将任何数组作为第二个参数。</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 舍入方法</li>
</ul>
<p>下面来介绍将小数值舍入为整数的几个方法:Math.ceil()、Math.floor()和Math.round()。这三个方法分别遵循下列舍入规则:</p>
<ul>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数;</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数;</li>
<li><p>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alert(Math.ceil(25.9));     //26</div><div class="line">alert(Math.ceil(25.5));     //26</div><div class="line">alert(Math.ceil(25.1));     //26</div><div class="line">alert(Math.round(25.9));    //26</div><div class="line">alert(Math.round(25.5));    //26</div><div class="line">alert(Math.round(25.1));    //25</div><div class="line">alert(Math.floor(25.9));    //25</div><div class="line">alert(Math.floor(25.5));    //25</div><div class="line">alert(Math.floor(25.1));    //25</div></pre></td></tr></table></figure>
</li>
<li><p>[x] random()方法</p>
</li>
</ul>
<p>Math.random()方法返回大于等于 0 小于 1 的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。套用下面的公式，就可以利用Math.random() 从某个整数范围内随机选择一个值。</p>
<p><strong>==值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)==</strong></p>
<p>公式中用到了 Math.floor()方法，这是因为 Math.random()总返回一个小数值。而用这个小数 值乘以一个整数，然后再加上一个整数，最终结果仍然还是一个小数。举例来说，如果你想选择一个 1 到 10 之间的数值，可以像下面这样编写代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var num = Math.floor(Math.random() * 10 + 1);</div></pre></td></tr></table></figure>
<p>总共有 10 个可能的值(1到10)，而第一个可能的值是1。而如果想要选择一个介于 2 到 10 之间的值，就应该将上面的代码改成这样:<br>var num = Math.floor(Math.random() * 9 + 2);</p>
<p>从 2 数到 10 要数9个数，因此可能值的总数就是 9，而第一个可能的值就是 2。多数情况下，其实 都可以通过一个函数来计算可能值的总数和第一个可能的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function selectFrom(lowerValue, upperValue) &#123;</div><div class="line">    var choices = upperValue - lowerValue + 1;</div><div class="line">    return Math.floor(Math.random() * choices + lowerValue);</div><div class="line">&#125;</div><div class="line">var num = selectFrom(2, 10);</div><div class="line">alert(num); // 介于2和10之间(包括2和10)的一个数值</div></pre></td></tr></table></figure></p>
<p>从数组中随机 取出一项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;purple&quot;, &quot;brown&quot;]; </div><div class="line">var color = colors[selectFrom(0, colors.length-1)];</div><div class="line">alert(color);//可能是数组中包含的任何一个字符串</div></pre></td></tr></table></figure></p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 其他方法(略)</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象， 现简要总结如下:</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 引用类型与传统面向对象程序设计中的类相似，但实现不同</li>
<li style="list-style: none"><input type="checkbox" checked> Object是一个基础类型，其他所有类型都从 Object继承了基本的行为;</li>
<li style="list-style: none"><input type="checkbox" checked> Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能;</li>
<li style="list-style: none"><input type="checkbox" checked> Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能;</li>
<li style="list-style: none"><input type="checkbox" checked> RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表 达式功能。</li>
</ul>
<p>函数实际上是Function类型的实例，因此函数也是对象;而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。</p>
<p>因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类 型分别是:Boolean、Number和String。以下是它们共同的特征:</p>
<ul>
<li>每个包装类型都映射到同名的基本类型;</li>
<li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作;</li>
<li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。</li>
</ul>
<p>在所有代码执行之前，作用域中就已经存在两个内置对象:Global 和 Math。在大多数 ECMAScript 实现中都不能直接访问 Global 对象;不过，Web 浏览器实现了承担该角色的 window 对象。全局变 量和函数都是 Global 对象的属性。Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算 任务。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/blog/2017/11/28/20171128 js引用类型/">js 引用类型</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Lucien</a></p>
        <p><span>发布时间:</span>2017-11-28, 20:31:49</p>
        <p><span>最后更新:</span>2017-11-28, 20:32:38</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/blog/2017/11/28/20171128 js引用类型/" title="js 引用类型">https://github.com/jialuchun/blog/2017/11/28/20171128 js引用类型/</a>
            <span class="copy-path" data-clipboard-text="原文: https://github.com/jialuchun/blog/2017/11/28/20171128 js引用类型/　　作者: Lucien" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/blog/2017/12/26/20171226 js面向对象的程序设计/">
                    js 面向对象的程序设计
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/blog/2017/10/19/20171019 js变量、作用域、内存/">
                    js 变量、作用域、内存
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引用类型"><span class="toc-number">1.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Object类型"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Object类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Array类型"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Array类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-检测数组"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 检测数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-转换方法"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-栈方法"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 栈方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-队列方法"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.2.4 队列方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-重排序方法"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.2.5 重排序方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-操作方法"><span class="toc-number">1.2.6.</span> <span class="toc-text">1.2.6 操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-7-位置方法"><span class="toc-number">1.2.7.</span> <span class="toc-text">1.2.7 位置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-8-迭代方法"><span class="toc-number">1.2.8.</span> <span class="toc-text">1.2.8 迭代方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-9归并方法"><span class="toc-number">1.2.9.</span> <span class="toc-text">1.2.9归并方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Date类型"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Date类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-RegExp类型"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 RegExp类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Function类型"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 Function类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-函数声明与函数表达式"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 函数声明与函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-作为值的函数"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 作为值的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-函数内部属性"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.5.3 函数内部属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-4-函数属性和方法"><span class="toc-number">1.5.4.</span> <span class="toc-text">1.5.4 函数属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-6-基本包装类型"><span class="toc-number">1.5.5.</span> <span class="toc-text">1.5.6 基本包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean类型"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">Boolean类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number类型"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">Number类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String类型"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-字符方法"><span class="toc-number">1.5.5.3.1.</span> <span class="toc-text">1. 字符方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-字符串操作方法"><span class="toc-number">1.5.5.3.2.</span> <span class="toc-text">2. 字符串操作方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-字符串位置方法"><span class="toc-number">1.5.5.3.3.</span> <span class="toc-text">3. 字符串位置方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-trim-方法"><span class="toc-number">1.5.5.3.4.</span> <span class="toc-text">4. trim()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-字符串大小写转换方法"><span class="toc-number">1.5.5.3.5.</span> <span class="toc-text">5. 字符串大小写转换方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-split"><span class="toc-number">1.5.5.3.6.</span> <span class="toc-text">6. split()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-7-单体内置对象"><span class="toc-number">1.5.6.</span> <span class="toc-text">1.5.7 单体内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Global对象"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">1. Global对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Math对象"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">2. Math对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">1.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"js 引用类型　| Blogs Of Lucien　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/blog/2017/12/26/20171226 js面向对象的程序设计/" title="上一篇: js 面向对象的程序设计">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/blog/2017/10/19/20171019 js变量、作用域、内存/" title="下一篇: js 变量、作用域、内存">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2018/01/04/20180104 js函数表达式/">js 函数表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/12/26/20171226 js面向对象的程序设计/">js 面向对象的程序设计</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/11/28/20171128 js引用类型/">js 引用类型</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/10/19/20171019 js变量、作用域、内存/">js 变量、作用域、内存</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/10/14/20171014 js基本概念/">js 基本概念</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2017/09/17/20170921 js组成/">js 组成</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 Lucien
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/blog/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
             title: "a.article-title, .article-more-link a", 
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>